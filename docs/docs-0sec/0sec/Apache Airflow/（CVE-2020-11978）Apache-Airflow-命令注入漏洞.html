<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-11978）Apache Airflow 命令注入漏洞</h1><h2>一、漏洞简介</h2><p>默认情况下Airflow Web UI是未授权访问的，直接可以登录，而登录后，只能查看DAG的调度状态等，无法进行更多操作。<br />但Airflow Web UI中提供了触发DAG运行的功能，以便测试DAG，同时Airflow为了让使用者可以快速熟悉其DAG开发流程和功能，为了更好的示例这些DAG覆盖了大多的执行器。而其中两个DAG组合起来可触发命令注入导致漏洞产生。</p><p><strong>要在WEB UI中先执行下启用DAG，然后才可以执行运行，如下所示</strong></p><p>2.png</p><h2>二、漏洞影响</h2><p>Apache Airflow &lt; 1.10.11</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>首先看下下面两个DAG</p><p>#airflow/example_dags/example_trigger_target_dag.py<br />from airflow import DAG<br />from airflow.operators.bash import BashOperator<br />from airflow.operators.python import PythonOperator<br />from airflow.utils.dates import days_ago<br /><br />dag = DAG(<br />    dag_id="example_trigger_target_dag",<br />    default_args={"start_date": days_ago(2), "owner": "airflow"},<br />    schedule_interval=None,<br />    tags=['example']<br />)<br /><br /><br />def run_this_func(**context):<br />    """<br />    Print the payload "message" passed to the DagRun conf attribute.<br /><br />    :param context: The execution context<br />    :type context: dict<br />    """<br />    print("Remotely received value of {} for key=message".format(context["dag_run"].conf["message"]))<br /><br /><br />run_this = PythonOperator(task_id="run_this", python_callable=run_this_func, dag=dag)<br /><br />bash_task = BashOperator(<br />    task_id="bash_task",<br />    bash_command='echo &quot;Here is the message: \'{{ dag_run.conf[&quot;message&quot;] if dag_run else &quot;&quot; }}\'&quot;',<br />    dag=dag,<br />)<br />#airflow/example_dags/example_trigger_controller_dag.py<br />from airflow import DAG<br />from airflow.operators.dagrun_operator import TriggerDagRunOperator<br />from airflow.utils.dates import days_ago<br /><br />dag = DAG(<br />    dag_id="example_trigger_controller_dag",<br />    default_args={"owner": "airflow", "start_date": days_ago(2)},<br />    schedule_interval="@once",<br />    tags=['example']<br />)<br /><br />trigger = TriggerDagRunOperator(<br />    task_id="test_trigger_dagrun",<br />    trigger_dag_id="example_trigger_target_dag",  # Ensure this equals the dag_id of the DAG to trigger<br />    conf={"message": "Hello World"},<br />    dag=dag,<br />)</p><p>官方对这两个DAG的说明如下：</p><p>Example usage of the TriggerDagRunOperator. This example holds 2 DAGs:<br />1. 1st DAG (example_trigger_controller_dag) holds a TriggerDagRunOperator, which will trigger the 2nd DAG<br />2. 2nd DAG (example_trigger_target_dag) which will be triggered by the TriggerDagRunOperator in the 1st DAG</p><p>可以看出Airflow希望通过这两个DAG组合来展示如果通过一个DAG（example_trigger_controller_dag）来动态的调用另外一个DAG（example_trigger_target_dag）。即通过example_trigger_controller_dag内部定义的conf={&quot;message&quot;: &quot;Hello World&quot;}来触发example_trigger_target_dag中bash_command='echo &quot;Here is the message: \'{{ dag_run.conf[&quot;message&quot;] if dag_run else &quot;&quot; }}\'&quot;'的运行，此处看起来：<br />存在命令执行点'echo &quot;Here is the message: \'{{ dag_run.conf[&quot;message&quot;] if dag_run else &quot;&quot; }}\'&quot;'<br />这边是Python下面的Jinja模板，因此会根据后面的if...else逻辑来执行dag_run.conf["message"] 来动态加载内容，此处如果dag_run.conf["message"] 可控，则可以通过Jinja模板注入恶意命令。</p><p>但根据上面信息可以看出，输入dag_run.conf["message"]由第一个DGA传递过来的，看起来无法控制。而实际上熟悉下Airflow相关代码即可发现，Airflow中A DAG Run is an object representing an instantiation of the DAG in time.而其中conf 正是用于传递参数的方式， Airflow提供了多渠道可以修改conf，包括命令行例如：</p><p>airflow dags trigger --conf '{&quot;conf1&quot;: &quot;value1&quot;}' example_parametrized_dag</p><p>同时也包含Web UI 上直接触发任意DAG并传递dag_run.conf：<br />1.png</p><p>详细信息可以参考Airflow官方文档中队dag_run的详细说明：</p><p>http://airflow.apache.org/docs/stable/dag-run.html?highlight=dag_run</p><p>因此可以直接利用此接口触发example_trigger_target_dag.py的调度，这样就可以绕过example_trigger_controller_dag中写死的配置。</p><p>3.png</p><p>4.png</p><h2>参考链接</h2><p>https://xz.aliyun.com/t/8037#toc-4</p></body></html>