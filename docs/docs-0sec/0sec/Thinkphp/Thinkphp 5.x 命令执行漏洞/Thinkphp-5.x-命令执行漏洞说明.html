<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>Thinkphp 5.x 命令执行漏洞说明</h1><p><strong>先简单说明一下吧，5.x我们这里罗列了目前碰到的全部tp系列的对应版本漏洞，我在这里简要说明一下，不看别后悔</strong></p><p>tp框架系列中，5.0.x 跟 5.1.x 中，各个系列里的poc是几乎为通用的</p><p>比如 5.0.1中某个poc在5.0.3中也是可以用的，也就是说当我们碰到5.0.8的时候，可以尝试用5.0.1 或 5.0.5等 5.0.x 系列的poc去尝试使用，</p><p>5.1.x 系列同理</p><h2>执行流程：</h2><p>首先发起请求-&gt;开始路由检测-&gt;获取pathinfo信息-&gt;路由匹配-&gt;开始路由解析-&gt;获得模块、控制器、操作方法调度信息-&gt;开始路由调度-&gt;解析模块和类名-&gt;组建命名空间&gt;查找并加载类-&gt;实例化控制器并调用操作方法-&gt;构建响应对象-&gt;响应输出-&gt;日志保存-&gt;程序运行结束</p><h2>漏洞原因：</h2><p>路由控制不严谨，默认不开启强制路由，从而可以任意调用Thinkphp的类库</p><p>主要有俩种方法，<strong>1.Request中的变量覆盖导致RCE 2.路由控制不严谨导致的RCE</strong></p><h2>Request中的变量覆盖导致RCE</h2><p>版本名 是否可被攻击 攻击条件<br />5.0.0 否 无<br />5.0.1 否 无<br />5.0.2 否 无<br />5.0.3 否 无<br />5.0.4 否 无<br />5.0.5 否 无<br />5.0.6 否 无<br />5.0.7 否 无<br />5.0.8 是 无需开启debug<br />5.0.9 是 无需开启debug<br />5.0.10 是 无需开启debug<br />5.0.11 是 无需开启debug<br />5.0.12 是 无需开启debug<br />5.0.13 是 需开启debug<br />5.0.14 是 需开启debug<br />5.0.15 是 需开启debug<br />5.0.16 是 需开启debug<br />5.0.17 是 需开启debug<br />5.0.18 是 需开启debug<br />5.0.19 是 需开启debug<br />5.0.20 否 无<br />5.0.21 是 需开启debug<br />5.0.22 是 需开启debug<br />5.0.23 是 需开启debug</p><h2>路由控制不严谨导致的RCE</h2><p>5.0.23--5.1.31版本</p><h2>补充</h2><p>由于受windows系统的影响，会导致部分payload在windows主机无法使用</p><p>并且由于windows自动加载类加载不到想要的类文件，所以能够下手的就是在框架加载的时候已经加载的类。</p><p><strong>5.1是下面这些：</strong></p><p>think\Loader <br />Composer\Autoload\ComposerStaticInit289837ff5d5ea8a00f5cc97a07c04561<br />think\Error <br />think\Container<br />think\App <br />think\Env <br />think\Config <br />think\Hook <br />think\Facade<br />think\facade\Env<br />env<br />think\Db<br />think\Lang <br />think\Request <br />think\Log <br />think\log\driver\File<br />think\facade\Route<br />route<br />think\Route <br />think\route\Rule<br />think\route\RuleGroup<br />think\route\Domain<br />think\route\RuleItem<br />think\route\RuleName<br />think\route\Dispatch<br />think\route\dispatch\Url<br />think\route\dispatch\Module<br />think\Middleware<br />think\Cookie<br />think\View<br />think\view\driver\Think<br />think\Template<br />think\template\driver\File<br />think\Session<br />think\Debug<br />think\Cache<br />think\cache\Driver<br />think\cache\driver\File</p><p><strong>5.0 的有：</strong></p><p>think\Route<br />think\Config<br />think\Error<br />think\App<br />think\Request<br />think\Hook<br />think\Env<br />think\Lang<br />think\Log<br />think\Loader</p><p><strong>两个版本公有的是：</strong></p><p>think\Route <br />think\Loader <br />think\Error <br />think\App <br />think\Env <br />think\Config <br />think\Hook <br />think\Lang <br />think\Request <br />think\Log</p><p>本想找出两个版本共有的利用类和方法，但由于类文件大多被重写了，所以没耐住性子一一去找（菜）</p><p>所以，payload为上述类的利用方法，是可以兼容windows和linux多个平台的，兼容多个平台有什么用呢？插件批量可以减少误判等，一条payload通用，一把梭多好。</p></body></html>