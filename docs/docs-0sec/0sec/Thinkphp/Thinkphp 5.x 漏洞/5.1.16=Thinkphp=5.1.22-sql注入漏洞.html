<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>5.1.16 &lt;= Thinkphp &lt;= 5.1.22</h1><h2>一、漏洞简介</h2><p>本篇文章，将分析 <strong>ThinkPHP</strong> 中存在的 <strong>SQL注入</strong> 漏洞（ <strong>orderby</strong> 方法注入）。本次漏洞存在于 <strong>Builder</strong> 类的 <strong>parseOrder</strong> 方法中。由于程序没有对数据进行很好的过滤，直接将数据拼接进 <strong>SQL</strong> 语句，最终导致 <strong>SQL注入漏洞</strong> 的产生。</p><h2>二、漏洞影响</h2><p>5.1.16 &lt;= Thinkphp &lt;= 5.1.22</p><h2>三、复现过程</h2><h3>漏洞环境</h3><p>通过以下命令获取测试环境代码：</p><p>composer create-project --prefer-dist topthink/think=5.1.22 tpdemo</p><p>将 <strong>composer.json</strong> 文件的 <strong>require</strong> 字段设置成如下：</p><p>"require": {<br />    "php": "&gt;=5.6.0",<br />    "topthink/framework": "5.1.22"<br />}</p><p>然后执行 composer update ，并将 <strong>application/index/controller/Index.php</strong> 文件代码设置如下：</p><p>&lt;?php<br />namespace app\index\controller;<br /><br />class Index<br />{<br />    public function index()<br />    {<br />        $orderby = request()-&gt;get('orderby');<br />        $result = db('users')-&gt;where(['username' =&gt; 'mochazz'])-&gt;order($orderby)-&gt;find();<br />        var_dump($result);<br />    }<br />}</p><p>在 <strong>config/database.php</strong> 文件中配置数据库相关信息，并开启 <strong>config/app.php</strong> 中的 <strong>app_debug</strong> 和 <strong>app_trace</strong> 。创建数据库信息如下：</p><p>create database tpdemo;<br />use tpdemo;<br />create table users(<br />    id int primary key auto_increment,<br />    username varchar(50) not null<br />);<br />insert into users(id,username) values(1,'mochazz');</p><p>访问 <strong>http://localhost:8000/index/index/index?orderby[id`|updatexml(1,concat(0x7,user(),0x7e),1)%23]=1</strong> 链接，即可触发 <strong>SQL注入漏洞</strong> 。（没开启 <strong>app_debug</strong> 是无法看到 <strong>SQL</strong> 报错信息的）</p><p>1.png</p><h3>漏洞分析</h3><p>首先在官方发布的 <strong>5.1.23</strong> 版本更新说明中，发现其中提到该版本增强了 <strong>order</strong> 方法的安全性。</p><p>2.png</p><p>通过查阅其 <strong>commit</strong> 记录，发现其修改了 <strong>Builder.php</strong> 文件中的 <strong>parseOrder</strong> 方法。其添加了一个 <strong>if</strong> 语句判断，来过滤 <strong>)、#</strong> 两个符号。</p><p>3.png</p><p>接下来，我们直接跟着上面的攻击 <strong>payload</strong> 来看看漏洞原理。首先程序通过 <strong>input</strong> 方法获取数据，并通过 <strong>filterCalue</strong> 方法进行简单过滤，但是根本没有对数组的键进行过滤处理。</p><p>4.png</p><p>接着数据就原样被传入数据库操作相关方法中。在 <strong>Query</strong> 类的 <strong>order</strong> 方法中，我们可以看到数据没有任何过滤，直接存储在 <strong>$this-&gt;options['order']</strong> 中。（下图 <strong>第19行</strong> ）</p><p>5.png</p><p>接着来到 <strong>find</strong> 方法，在 <strong>Connection</strong> 类的 <strong>find</strong> 方法中调用 <strong>Builder</strong> 类的 <strong>select</strong> 方法来生成 <strong>SQL</strong> 语句。相信大家对 <strong>Builder</strong> 类的 <strong>select</strong> 方法应该不会陌生吧，因为前几篇分析文章中都有提及这个方法。这个方法通过 <strong>str_replace</strong> 函数将数据填充到 <strong>SQL</strong> 模板语句中。这次我们要关注的是 <strong>parseOrder</strong> 方法，这个方法在新版的 <strong>ThinkPHP</strong> 中做了代码调整，我们跟进。</p><p>6.png</p><p>在 <strong>parseOrder</strong> 方法中，我们看到程序通过 <strong>parseKey</strong> 方法给变量两端都加上了反引号（下图 <strong>第26行</strong> ），然后直接拼接字符串返回（下图 <strong>第17行</strong> ），没有进行任何过滤、检测，这也是导致本次 <strong>SQL注入漏洞</strong> 的原因。</p><p>7.png</p><h3>漏洞修复</h3><p>官方的修复方法是：在拼接字符串前对变量进行检查，看是否存在 <strong>)、#</strong> 两个符号。</p><p>3.png</p><h3>攻击总结</h3><p>最后，再通过一张攻击流程图来回顾整个攻击过程。</p><p>8.png</p><h2>参考链接</h2><p>https://github.com/Mochazz/ThinkPHP-Vuln</p></body></html>