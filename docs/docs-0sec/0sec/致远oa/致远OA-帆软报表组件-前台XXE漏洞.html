<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>致远OA 帆软报表组件 前台XXE漏洞</h1><h2>一、漏洞简介</h2><h2>二、漏洞影响</h2><p>致远A6-V5 V6.1<br />致远A6-V5 V6.1SP1<br />致远A8-V5 V6.1SP1<br />致远A8-V5 V6.1SP2</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>分析 xml 文件</p><p>/A8/ApacheJetspeed/webapps/seeyonreport/WEB-INF/web.xml</p><p>找到并分析对url: /seeyonreport/SeeyonReportServiceServlet 的请求处理类 com.seeyon.ctp.seeyonreport.service.SeeyonReportServiceServlet</p><p>&lt;servlet&gt;<br />    &lt;servlet-name&gt;SeeyonReportServiceServlet&lt;/servlet-name&gt;<br />    &lt;servlet-class&gt;com.seeyon.ctp.seeyonreport.service.SeeyonReportServiceServlet&lt;/servlet-class&gt;<br />    &lt;load-on-startup&gt;2&lt;/load-on-startup&gt;<br />&lt;/servlet&gt;<br /><br />&lt;servlet-mapping&gt;<br />    &lt;servlet-name&gt;SeeyonReportServiceServlet&lt;/servlet-name&gt;<br />    &lt;url-pattern&gt;/SeeyonReportServiceServlet&lt;/url-pattern&gt;<br />&lt;/servlet-mapping&gt;</p><p>跟入 Servlet 的 doPost 方法中</p><p>protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br />}</p><p>找到 case SELECT流程</p><p>case SELECT:<br />    this.execSelect(request, response);<br />    break;</p><p>跟入 this.execSelect 函数，如下：</p><p>public void execSelect(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br />    PrintWriter pw = response.getWriter();<br />    String dataSetName = request.getParameter("dataSetName");<br />    List&lt;String&gt; tableDataNames = SeeyonReportCommonUtil.getTemplateServerTableDataNames(dataSetName);<br />    Collections.sort(tableDataNames);<br />    String json = JSONHelper.list2json(tableDataNames);<br />    pw.write(json);<br />    pw.close();<br />}</p><p>获取了下 dataSetName 请求参数的值，传入 SeeyonReportCommonUtil.getTemplateServerTableDataNames() 函数，继续跟进：</p><p>public static List&lt;String&gt; getTemplateServerTableDataNames(String cptName) {<br />    List&lt;String&gt; tableDataNames = getTemplateTableDataNames(cptName);<br />    List&lt;String&gt; serverDataSet = new ArrayList();<br />    List&lt;String&gt; allDataSet = getTemplateAllTableDataNames(cptName);<br />    Iterator iter = allDataSet.iterator();<br /><br />    while(iter.hasNext()) {<br />        String name = (String)iter.next();<br />        if (!tableDataNames.contains(name)) {<br />            serverDataSet.add(name);<br />        }<br />    }<br /><br />    return serverDataSet;<br />}</p><p>参数值先进入了 getTemplateTableDataNames ，然后又传入了 getTemplateAllTableDataNames 函数。</p><p>看一下后面的 getTemplateAllTableDataNames 函数（部分代码省略）：</p><p>public static List&lt;String&gt; getTemplateAllTableDataNames(String cptName) {<br />    List&lt;Element&gt; rEles = getWorkBookElement(WorkBook.Report, cptName);<br />    List&lt;String&gt; serverDataSet = new ArrayList();<br />    if (!rEles.isEmpty()) {<br />        Iterator var3 = rEles.iterator();<br />        while(var3.hasNext()) {<br />            ……<br />                }<br />    }<br />    return serverDataSet;<br />}</p><p>发现开始的请求参数 dataSetName 的值被当做 cptName，传入 getWorkBookElement(WorkBook.Report, cptName)函数中，继续跟进：</p><p>public static List&lt;Element&gt; getWorkBookElement(WorkBook wb, String cptName) {<br />    Env env = FRContext.getCurrentEnv();<br />    List eles = null;<br /><br />    try {<br />        SAXReader reader = new SAXReader();<br />        boolean isExist = env.isTemplateExist(cptName);<br />        if (isExist) {<br />            String reportPath = StableUtils.pathJoin(new String[]{env.getPath(), "reportlets", cptName});<br />            File file = new File(reportPath);<br />            Document document = reader.read(file);<br />            Element root = document.getRootElement();<br />            List&lt;Element&gt; childElements = root.elements();<br />            if (!childElements.isEmpty()) {<br />                Iterator var11 = childElements.iterator();<br /><br />                while(var11.hasNext()) {<br />                    Element el = (Element)var11.next();<br />                    if (el.getName().equals(wb.name())) {<br />                        eles = el.elements();<br />                        break;<br />                    }<br />                }<br />            }<br />        }<br />    } catch (Exception var13) {<br />        LOG.error(var13);<br />    }<br /><br />    return eles;<br />}</p><p>可以发现 cptName 貌似被拼接到了路径中，进入 StableUtils.pathJoin 也没发现对特殊字符的过滤，到这里其实已经可以通过 ../ 跳目录，控制 reportPath 值，传入一个我们指定的文件路径：</p><p>String reportPath = StableUtils.pathJoin(new String[]{env.getPath(), "reportlets", cptName})</p><p>再结合 xxe 的示范级写法：</p><p>SAXReader reader = new SAXReader();<br />File file = new File(reportPath);<br />Document document = reader.read(file);</p><p>只要传入一个带有 XXE 载荷的本地文件路径，就可以触发 XXE 漏洞了。</p><p>正好，2019 年HW行动期间爆出来一个 帆软报表v8.0 Getshell漏洞，里面就有一个 未授权插件上传，文件内容可控并且路径固定：</p><p>/A8/ApacheJetspeed/webapps/seeyonreport/WEB-INF/cache/temp.zip</p><p>当然，如果有其他可以控制上传文件内容的方法，也可以。</p><h3>漏洞复现</h3><ol class="pydocx-list-style-type-decimal"><li>通过未授权插件上传，将 XXE 载荷保存到固定路径文件：<br />/A8/ApacheJetspeed/webapps/seeyonreport/WEB-INF/cache/temp.zip</li><li>通过 /seeyonreport/SeeyonReportServiceServlet 接口，跳目录后，使用 SAXReade 读取 temp.zip 文件即可。</li></ol><h3>参考链接</h3><p>https://landgrey.me/blog/8/</p></body></html>