<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-13933）Apache Shiro &lt; 1.6.0 身份认证绕过漏洞</h1><h2>一、漏洞简介</h2><p>2020年8月18日，Apache Shiro官方发布安全通告 Apache Shiro身份验证绕过漏洞（CVE-2020-13933），经过分析，攻击者可以通过构造特殊的HTTP请求实现身份验证绕过。</p><h2>二、漏洞影响</h2><p>Apache Shiro &lt; 1.6.0</p><h2>三、复现过程</h2><h3>漏洞分析</h3><p>根据shiro历史上的认证绕过漏洞，本质问题就是springboot对url的处理和shiro的处理不一致导致的认证绕过。<br />其中shiro的url处理的问题都出在org/apache/shiro/web/util/WebUtils.java类下面，在return</p><p>    public static String getPathWithinApplication(HttpServletRequest request) {<br />        return normalize(removeSemicolon(getServletPath(request) + getPathInfo(request)));<br />    }</p><p>断点，<br />然后我们去springboot的处理url的地方进行断点，org/springframework/web/util/UrlPathHelper.java。</p><p>在return uri；进行</p><p>    private String decodeAndCleanUriString(HttpServletRequest request, String uri) {<br />        uri = removeSemicolonContent(uri);<br />        uri = decodeRequestString(request, uri);<br />        uri = getSanitizedPath(uri);<br />        return uri;<br />    }</p><p>断点。</p><p>访问/test/%3bname，先来到shiro的url处理块，</p><p>1.jpg</p><p>根据图纸可知，获取到的url在处理前已经进行了一次urldecode。然后在进入removeSemicolon操作，最后结果集在交给normalize操作。</p><p>根据计算器可知removeSemicolon会把url里;后面的内容给删除(包括;)</p><p>2.jpg</p><p>跟进removeSemicolon看看。</p><p>实现代码如下:</p><p>    private static String removeSemicolon(String uri) {<br />        int semicolonIndex = uri.indexOf(';');<br />        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);<br />    }</p><p>确实是把;后面的内容给删除(包括;)了。</p><p>一路F8，最后果然把/test/赋值给requestURI变量了。</p><p>3.jpg</p><p>根据测试当初访问/test/</p><p>4.jpg</p><p>可以看到，如果test目录的话，是默认有权限访问的，但是/test/后面的路由是需要验证的。</p><p>5.jpg</p><p>接着我们来到springboot，看看springboot是怎么处理URL的问题。</p><p>6.jpg</p><p>uri取到的是/test/;name，可以看到springboot对url做了三个操作后才返回的，removeSemicolonContent,decodeRequestString,getSanitizedPath。</p><ul><li>removeSemicolonContent 是把（url未解码前的uri里的;后面的内容给删除）</li><li>decodeRequestString把uri进行urldecode编码</li><li>getSanitizedPath 是把”//“ 替换成 “/“<br />这是简单对比下shiro的对url的操作顺序:</li><li>uri 进行urldecode</li><li>uri 删除;后面的内容，包括;</li></ul><p>因为shiro的处理和springboot的处理顺序不同，导致我们构造的poc在shiro侧理解的是访问的/test/，/test/我们本身就没有限制权限，放过了这个原本需要认证权限的请求，而springboot侧则是访问的是/test/;name，然后springboot把;name当做一个字符串去寻找对应的路由，返回了对应的字符串。</p><h3>漏洞复现</h3><p>正常请求如下所示</p><p>7.jpg</p><p>8.jpg</p><p>构造恶意请求test/%3b{name}</p><p>9.jpg</p><h2>参考链接</h2><p>https://www.anquanke.com/post/id/214964#h2-2</p></body></html>