<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h2>PHP序列化和反序列化语法差异问题</h2><h2>介绍</h2><p>官方文档中介绍PHP序列化和反序列化如下：</p><p>所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。<br /><br />为了能够unserialize()一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。</p><p>简单说序列化是对象转化字符串的过程，反序列化是字符串还原对象的过程。</p><h2>环境</h2><p>文章中所述内容使用环境如下:</p><p>PHP7.3.1、SDK<br /><br />VSCode<br /><br />C++和C</p><p>环境配置建议参考：《WINDOWS下用VSCODE调试PHP7源代码》<a href="https://www.jianshu.com/p/29bc0443***6">https://www.jianshu.com/p/29bc0443<em>*</em>6</a> (作者经过几小时尝试后找到最全的版本)</p><p>在网上公开参数反序列化执行流程已经非常详细，但是对于一些细节地方有一些不足，其中就包括序列化和反序列化之间的语法差异问题</p><h2>差异问题</h2><h4><em>序列化</em></h4><p>我们通过编译PHP内核源码分析，发现PHP序列化在默认情况下在对象转换中加入:{和}用来拼接成字符串。</p><p>[var.c]<br />Line:882<br />static void php_var_serialize_intern()<br /><br />Line:896<br />if (ce-&gt;serialize(struc, &amp;serialized_data, &amp;serialized_length, (zend_serialize_data *)var_hash) == SUCCESS) {<br />                        smart_str_appendl(buf, "C:", 2);<br />                        smart_str_append_unsigned(buf, ZSTR_LEN(Z_OBJCE_P(struc)-&gt;name));<br />                        smart_str_appendl(buf, ":\"", 2);<br />                        smart_str_append(buf, Z_OBJCE_P(struc)-&gt;name);<br />                        smart_str_appendl(buf, "\":", 2);<br /><br />                        smart_str_append_unsigned(buf, serialized_length);<br />                        smart_str_appendl(buf, ":{", 2);<br />                        smart_str_appendl(buf, (char *) serialized_data, serialized_length);<br />                        smart_str_appendc(buf, '}');<br />                    }<br /><br />Line:952<br />smart_str_appendl(buf, ":{", 2);<br /><br />Line:995<br />smart_str_appendc(buf, '}');</p><p>咱们来看上面这段代码，PHP会使用smart_str_appendl为序列化字符串前后拼接:{和}，从var.c的第882行开始进入序列化逻辑。在第896行进行序列化字符串拼接，第952行和第995行，对于内嵌方法进行拼接。</p><h4><em>反序列化</em></h4><p>反序列化是将序列化的字符串，按照一定语法规则进行转化还原。</p><p>[var_unserialize.c]<br />Line:655<br />static int php_var_unserialize_internal()<br /><br />Line:674<br />{<br />    YYCTYPE yych;<br />    static const unsigned char yybm[] = {<br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />        128, 128, 128, 128, 128, 128, 128, 128, <br />        128, 128,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />          0,   0,   0,   0,   0,   0,   0,   0, <br />    };<br />    if ((YYLIMIT - YYCURSOR) &lt; 7) YYFILL(7);<br />    yych = *YYCURSOR;<br />    switch (yych) {<br />    case 'C':<br />    case 'O':    goto yy4;<br />    case 'N':    goto yy5;<br />    case 'R':    goto yy6;<br />    case 'S':    goto yy7;<br />    case 'a':    goto yy8;<br />    case 'b':    goto yy9;<br />    case 'd':    goto yy10;<br />    case 'i':    goto yy11;<br />    case 'o':    goto yy12;<br />    case 'r':    goto yy13;<br />    case 's':    goto yy14;<br />    case '}':    goto yy15;<br />    default:    goto yy2;<br />    }<br /><br />Line:776<br />yy15:<br />    ++YYCURSOR;<br />    {<br />    /* this is the case where we have less data than planned */<br />    php_error_docref(NULL, E_NOTICE, "Unexpected end of serialized data");<br />    return 0; /* not sure if it should be 0 or 1 here? */<br />}</p><p>通过内核代码能够看到第655行进入反序列化，反序列化是利用词法扫描，判断各项符号转换对应对象。能够看到反序列化中对于}进行了处理，处理中只是对计数器加一并没有其他操作。</p><h2>实际作用</h2><p>反序列化语法的差异，对于安全防护设备判断反序列化产生很大的影响。在Snort中，有段规则如下：</p><p>alert tcp any any -&gt; any [80,8080,443] (uricontent:".php"; pcre:"/\{\w:.+?\}/"; sid:1; msg:php_serialize;)</p><p>在攻击载荷中可以使用大多数字符代替{},从而导致规则失效。</p><h2>总结</h2><p>在红队攻击中可以利用PHP序列化和反序列化语法差异，从而达到绕过防护的目的。</p><p>在蓝队防御中建议考虑定义中所述不会保存对象的方法，只会保存类的名字。，拦截保存类的名字，以及语法中相同的字符</p></body></html>