<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>Ecshop 从反序列化到类型混淆漏洞</h1><h2>一、漏洞简介</h2><h3>漏洞利用条件</h3><p>•php 5.6.x</p><p>•反序列化入口点</p><p>•可以触发__wakeup的触发点（在php &lt; 5.6.11以下，可以使用内置类）</p><h2>二、漏洞影响</h2><p>Ecshop 4.0.7</p><h2>三、复现过程</h2><p>首先我们需要找到一个反序列化入口点，这里我们可以全局搜索unserialize，挨个看一下我们可以找到两个可控的反序列化入口。</p><p>其中一个是search.php line 45</p><p>...<br />{<br />    $string = base64_decode(trim($_GET['encode']));<br /><br />    if ($string !== false)<br />    {<br />        $string = unserialize($string);<br />        if ($string !== false)<br />...</p><p>这是一个前台的入口，但可惜的是引入初始化文件在反序列化之后，这也就导致我们没办法找到可以覆盖类变量属性的目标，也就没办法进一步利用。</p><p>还有一个是admin/order.php line 229</p><p>    /* 取得上一个、下一个订单号 */<br />    if (!empty($_COOKIE['ECSCP']['lastfilter']))<br />    {<br />        $filter = unserialize(urldecode($_COOKIE['ECSCP']['lastfilter']));<br /><br />       ...</p><p>后台的表单页的这个功能就满足我们的要求了，不但可控，还可以用urlencode来绕过ecshop对全局变量的过滤。</p><p>这样一来我们就找到了一个可控并且合适的反序列化入口点。</p><h3>寻找合适的类属性利用链</h3><p>在寻找利用链之前，我们可以用</p><p>get_declared_classes()</p><p>来确定在反序列化时，已经声明定义过的类。</p><p>在我本地环境下，除了PHP内置类以外我一共找到13个类</p><p>  [129]=&gt;<br />  string(3) "ECS"<br />  [130]=&gt;<br />  string(9) "ecs_error"<br />  [131]=&gt;<br />  string(8) "exchange"<br />  [132]=&gt;<br />  string(9) "cls_mysql"<br />  [133]=&gt;<br />  string(11) "cls_session"<br />  [134]=&gt;<br />  string(12) "cls_template"<br />  [135]=&gt;<br />  string(11) "certificate"<br />  [136]=&gt;<br />  string(6) "oauth2"<br />  [137]=&gt;<br />  string(15) "oauth2_response"<br />  [138]=&gt;<br />  string(14) "oauth2_request"<br />  [139]=&gt;<br />  string(9) "transport"<br />  [140]=&gt;<br />  string(6) "matrix"<br />  [141]=&gt;<br />  string(16) "leancloud_client"</p><p>从代码中也可以看到在文件头引入了多个库文件</p><p>require(dirname(__FILE__) . '/includes/init.php');<br />require_once(ROOT_PATH . 'includes/lib_order.php');<br />require_once(ROOT_PATH . 'includes/lib_goods.php');<br />require_once(ROOT_PATH . 'includes/cls_matrix.php');<br />include_once(ROOT_PATH . 'includes/cls_certificate.php');<br />require('leancloud_push.php');</p><p>这里我们主要关注init.php，因为在这个文件中声明了ecshop的大部分通用类。</p><p>在逐个看这里面的类变量时，我们可以敏锐的看到一个特殊的变量，由于ecshop的后台结构特殊，页面内容大多都是由模板编译而成，而这个模板类恰好也在init.php中声明</p><p>require(ROOT_PATH . 'includes/cls_template.php');<br />$smarty = new cls_template;</p><p>回到order.php中我们寻找与$smarty相关的方法，不难发现，主要集中在两个方法中</p><p>...<br />    $smarty-&gt;assign('shipping', $shipping);<br /><br />    $smarty-&gt;display('print.htm');<br />...</p><p>而这里我们主要把视角集中在display方法上。</p><p>粗略的浏览下display方法的逻辑大致是</p><p>请求相应的模板文件<br />--&gt;<br />经过一系列判断，将相应的模板文件做相应的编译<br />--&gt;<br />输出编译后的文件地址</p><p>比较重要的代码会在make_compiled这个函数中被定义</p><p>function make_compiled($filename)<br />    {<br />        $name = $this-&gt;compile_dir . '/' . basename($filename) . '.php';<br /><br />        ...<br /><br />        if ($this-&gt;force_compile || $filestat['mtime'] &gt; $expires)<br />        {<br />            $this-&gt;_current_file = $filename;<br />            $source = $this-&gt;fetch_str(file_get_contents($filename));<br /><br />            if (file_put_contents($name, $source, LOCK_EX) === false)<br />            {<br />                trigger_error('can\'t write:' . $name);<br />            }<br /><br />            $source = $this-&gt;_eval($source);<br />        }<br /><br />        return $source;<br />    }</p><p>当流程走到这一步的时候，我们需要先找到我们的目标是什么？</p><p>重新审视cls_template.php的代码，我们可以发现涉及到代码执行的只有几个函数。</p><p>   function get_para($val, $type = 1) // 处理insert外部函数/需要include运行的函数的调用数据<br />    {<br />        $pa = $this-&gt;str_trim($val);<br />        foreach ($pa AS $value)<br />        {<br />            if (strrpos($value, '='))<br />            {<br />                list($a, $b) = explode('=', str_replace(array(' ', '&quot;', &quot;'&quot;, '&quot;'), '', $value));<br />                if ($b{0} == '$')<br />                {<br />                    if ($type)<br />                    {<br />                        eval('$para[\'' . $a . '\']=' . $this-&gt;get_val(substr($b, 1)) . ';');<br />                    }<br />                    else<br />                    {<br />                        $para[$a] = $this-&gt;get_val(substr($b, 1));<br />                    }<br />                }<br />                else<br />                {<br />                    $para[$a] = $b;<br />                }<br />            }<br />        }<br /><br />        return $para;<br />    }</p><p>get_para只在select中调用，但是没找到能触发select的地方。</p><p>然后是pop_vars</p><p>    function pop_vars()<br />    {<br />        $key = array_pop($this-&gt;_temp_key);<br />        $val = array_pop($this-&gt;_temp_val);<br /><br />        if (!empty($key))<br />        {<br />            eval($key);<br />        }<br />    }</p><p>恰好配合GMP我们可以控制$this-&gt;_temp_key变量，所以我们只要能在上面的流程中找到任意地方调用这个方法，我们就可以配合变量覆盖构造一个代码执行。</p><p>在回看刚才的代码流程时，我们从编译后的PHP文件中找到了这样的代码</p><p>order_info.htm.php</p><p>  &lt;?php endforeach; endif; unset($_from); ?&gt;&lt;?php $this-&gt;pop_vars();; ?&gt;</p><p>在遍历完表单之后，正好会触发pop_vars。</p><p>这样一来，只要我们控制覆盖cls_template变量的_temp_key属性，我们就可以完成一次getshell</p><h3>最终利用效果</h3><p>1.png</p><h2>参考链接</h2><p>https://mp.weixin.qq.com/s/KD0fKbSA9SUGY1lGas1xSA</p></body></html>